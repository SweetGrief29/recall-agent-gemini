import type { MessageList } from '../agent/message-list/index.js';
import type { TracingContext } from '../ai-tracing/index.js';
import type { IMastraLogger } from '../logger/index.js';
import type { ChunkType } from '../stream/index.js';
import type { MastraModelOutput } from '../stream/base/output.js';
import type { Processor } from './index.js';
/**
 * Implementation of processor state management
 */
export declare class ProcessorState {
    private accumulatedText;
    customState: Record<string, any>;
    streamParts: ChunkType[];
    constructor(_processorName: string);
    addPart(part: ChunkType): void;
}
export type ProcessorRunnerMode = 'stream' | 'result' | false;
export declare class ProcessorRunner {
    readonly inputProcessors: Processor[];
    readonly outputProcessors: Processor[];
    private readonly logger;
    private readonly agentName;
    constructor({ inputProcessors, outputProcessors, logger, agentName, }: {
        inputProcessors?: Processor[];
        outputProcessors?: Processor[];
        logger: IMastraLogger;
        agentName: string;
    });
    runOutputProcessors(messageList: MessageList, tracingContext?: TracingContext, telemetry?: any): Promise<MessageList>;
    /**
     * Process a stream part through all output processors with state management
     */
    processPart(part: ChunkType, processorStates: Map<string, ProcessorState>, tracingContext?: TracingContext): Promise<{
        part: ChunkType | null | undefined;
        blocked: boolean;
        reason?: string;
    }>;
    runOutputProcessorsForStream(streamResult: MastraModelOutput, tracingContext?: TracingContext): Promise<ReadableStream<any>>;
    runInputProcessors(messageList: MessageList, tracingContext?: TracingContext, telemetry?: any): Promise<MessageList>;
}
//# sourceMappingURL=runner.d.ts.map