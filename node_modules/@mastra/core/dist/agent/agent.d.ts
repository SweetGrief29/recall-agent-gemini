import type { WritableStream } from 'stream/web';
import type { CoreMessage, StreamObjectResult, UIMessage } from 'ai';
import type { JSONSchema7 } from 'json-schema';
import { z } from 'zod';
import type { ZodSchema } from 'zod';
import type { MastraPrimitives } from '../action/index.js';
import { AISpanType } from '../ai-tracing/index.js';
import type { AISpan, TracingContext, TracingOptions, TracingProperties } from '../ai-tracing/index.js';
import { MastraBase } from '../base.js';
import type { Metric } from '../eval/index.js';
import { MastraLLMV1 } from '../llm/model/index.js';
import type { GenerateObjectResult, GenerateTextResult, StreamTextResult } from '../llm/model/base.types.js';
import { MastraLLMVNext } from '../llm/model/model.loop.js';
import type { MastraLanguageModel } from '../llm/model/shared.types.js';
import type { Mastra } from '../mastra/index.js';
import type { MastraMemory } from '../memory/memory.js';
import type { MemoryConfig, StorageThreadType } from '../memory/types.js';
import { RuntimeContext } from '../runtime-context/index.js';
import type { ScorerRunInputForAgent, ScorerRunOutputForAgent, MastraScorers, MastraScorer } from '../scores/index.js';
import type { AISDKV5OutputStream } from '../stream/index.js';
import type { MastraModelOutput } from '../stream/base/output.js';
import type { OutputSchema } from '../stream/base/schema.js';
import type { ChunkType } from '../stream/types.js';
import type { CoreTool } from '../tools/types.js';
import type { DynamicArgument } from '../types.js';
import type { CompositeVoice } from '../voice/index.js';
import { DefaultVoice } from '../voice/index.js';
import type { Workflow } from '../workflows/index.js';
import { LegacyStep as Step } from '../workflows/legacy/index.js';
import type { AgentExecutionOptions, MultiPrimitiveExecutionOptions } from './agent.types.js';
import { MessageList } from './message-list/index.js';
import type { MessageInput, MessageListInput, UIMessageWithMetadata } from './message-list/index.js';
import { SaveQueueManager } from './save-queue/index.js';
import type { AgentConfig, AgentGenerateOptions, AgentStreamOptions, ToolsetsInput, ToolsInput } from './types.js';
export type MastraLLM = MastraLLMV1 | MastraLLMVNext;
export declare class Agent<TAgentId extends string = string, TTools extends ToolsInput = ToolsInput, TMetrics extends Record<string, Metric> = Record<string, Metric>> extends MastraBase {
    #private;
    id: TAgentId;
    name: TAgentId;
    model?: DynamicArgument<MastraLanguageModel>;
    evals: TMetrics;
    private _agentNetworkAppend;
    constructor(config: AgentConfig<TAgentId, TTools, TMetrics>);
    getMastraInstance(): Mastra<Record<string, Agent<any, ToolsInput, Record<string, Metric>>>, Record<string, import("../workflows/legacy").LegacyWorkflow<Step<string, any, any, import("../workflows/legacy").StepExecutionContext<any, import("../workflows/legacy").WorkflowContext<any, Step<string, any, any, any>[], Record<string, any>>>>[], string, any, any>>, Record<string, Workflow<any, import("..").Step<string, any, any, any, any, any>[], string, z.ZodType<any, z.ZodTypeDef, any>, z.ZodType<any, z.ZodTypeDef, any>, z.ZodType<any, z.ZodTypeDef, any>>>, Record<string, import("../vector").MastraVector<import("../vector/filter").VectorFilter>>, Record<string, import("../tts").MastraTTS>, import("../logger").IMastraLogger, Record<string, import("../network").AgentNetwork>, Record<string, import("../network/vNext").NewAgentNetwork>, Record<string, import("../mcp").MCPServerBase>, Record<string, MastraScorer<any, any, any, any>>> | undefined;
    listAgents({ runtimeContext }?: {
        runtimeContext?: RuntimeContext;
    }): Record<string, Agent<string, ToolsInput, Record<string, Metric>>> | Promise<Record<string, Agent<string, ToolsInput, Record<string, Metric>>>>;
    private getProcessorRunner;
    private getResolvedOutputProcessors;
    hasOwnMemory(): boolean;
    getMemory({ runtimeContext }?: {
        runtimeContext?: RuntimeContext;
    }): Promise<MastraMemory | undefined>;
    get voice(): CompositeVoice;
    getWorkflows({ runtimeContext, }?: {
        runtimeContext?: RuntimeContext;
    }): Promise<Record<string, Workflow>>;
    getScorers({ runtimeContext, }?: {
        runtimeContext?: RuntimeContext;
    }): Promise<MastraScorers>;
    getVoice({ runtimeContext }?: {
        runtimeContext?: RuntimeContext;
    }): Promise<CompositeVoice | DefaultVoice>;
    get instructions(): string;
    getInstructions({ runtimeContext }?: {
        runtimeContext?: RuntimeContext;
    }): string | Promise<string>;
    getDescription(): string;
    getDefaultGenerateOptions({ runtimeContext, }?: {
        runtimeContext?: RuntimeContext;
    }): AgentGenerateOptions | Promise<AgentGenerateOptions>;
    getDefaultStreamOptions({ runtimeContext }?: {
        runtimeContext?: RuntimeContext;
    }): AgentStreamOptions | Promise<AgentStreamOptions>;
    getDefaultVNextStreamOptions<Output extends ZodSchema | undefined, StructuredOutput extends ZodSchema | undefined>({ runtimeContext }?: {
        runtimeContext?: RuntimeContext;
    }): AgentExecutionOptions<Output, StructuredOutput> | Promise<AgentExecutionOptions<Output, StructuredOutput>>;
    get tools(): TTools;
    getTools({ runtimeContext }?: {
        runtimeContext?: RuntimeContext;
    }): TTools | Promise<TTools>;
    get llm(): MastraLLM | Promise<MastraLLM>;
    /**
     * Gets or creates an LLM instance based on the current model
     * @param options Options for getting the LLM
     * @returns A promise that resolves to the LLM instance
     */
    getLLM({ runtimeContext, model, }?: {
        runtimeContext?: RuntimeContext;
        model?: MastraLanguageModel | DynamicArgument<MastraLanguageModel>;
    }): MastraLLM | Promise<MastraLLM>;
    /**
     * Gets the model, resolving it if it's a function
     * @param options Options for getting the model
     * @returns A promise that resolves to the model
     */
    getModel({ runtimeContext }?: {
        runtimeContext?: RuntimeContext;
    }): MastraLanguageModel | Promise<MastraLanguageModel>;
    __updateInstructions(newInstructions: string): void;
    __updateModel({ model }: {
        model: DynamicArgument<MastraLanguageModel>;
    }): void;
    __registerPrimitives(p: MastraPrimitives): void;
    __registerMastra(mastra: Mastra): void;
    /**
     * Set the concrete tools for the agent
     * @param tools
     */
    __setTools(tools: TTools): void;
    generateTitleFromUserMessage({ message, runtimeContext, tracingContext, model, instructions, }: {
        message: string | MessageInput;
        runtimeContext?: RuntimeContext;
        tracingContext: TracingContext;
        model?: DynamicArgument<MastraLanguageModel>;
        instructions?: DynamicArgument<string>;
    }): Promise<string>;
    getMostRecentUserMessage(messages: Array<UIMessage | UIMessageWithMetadata>): UIMessage | UIMessageWithMetadata | undefined;
    genTitle(userMessage: string | MessageInput | undefined, runtimeContext: RuntimeContext, tracingContext: TracingContext, model?: DynamicArgument<MastraLanguageModel>, instructions?: DynamicArgument<string>): Promise<string | undefined>;
    fetchMemory({ threadId, thread: passedThread, memoryConfig, resourceId, runId, userMessages, systemMessage, messageList, runtimeContext, }: {
        resourceId: string;
        threadId: string;
        thread?: StorageThreadType;
        memoryConfig?: MemoryConfig;
        userMessages?: CoreMessage[];
        systemMessage?: CoreMessage;
        runId?: string;
        messageList?: MessageList;
        runtimeContext?: RuntimeContext;
    }): Promise<{
        threadId: string;
        messages: CoreMessage[];
    }>;
    private getMemoryTools;
    private __runInputProcessors;
    private __runOutputProcessors;
    private getMemoryMessages;
    private getAssignedTools;
    private getToolsets;
    private getClientTools;
    private getWorkflowTools;
    private convertTools;
    private formatTools;
    /**
     * Adds response messages from a step to the MessageList and schedules persistence.
     * This is used for incremental saving: after each agent step, messages are added to a save queue
     * and a debounced save operation is triggered to avoid redundant writes.
     *
     * @param result - The step result containing response messages.
     * @param messageList - The MessageList instance for the current thread.
     * @param threadId - The thread ID.
     * @param memoryConfig - The memory configuration for saving.
     * @param runId - (Optional) The run ID for logging.
     */
    private saveStepMessages;
    __primitive({ instructions, messages, context, thread, memoryConfig, resourceId, runId, toolsets, clientTools, runtimeContext, saveQueueManager, writableStream, methodType, tracingContext, tracingOptions, }: {
        instructions: string;
        toolsets?: ToolsetsInput;
        clientTools?: ToolsInput;
        resourceId?: string;
        thread?: (Partial<StorageThreadType> & {
            id: string;
        }) | undefined;
        memoryConfig?: MemoryConfig;
        context?: CoreMessage[];
        runId?: string;
        messages: MessageListInput;
        runtimeContext: RuntimeContext;
        saveQueueManager: SaveQueueManager;
        writableStream?: WritableStream<ChunkType>;
        methodType: 'generate' | 'stream';
        tracingContext?: TracingContext;
        tracingOptions?: TracingOptions;
    }): {
        before: () => Promise<{
            tripwire?: boolean | undefined;
            tripwireReason?: string | undefined;
            messageObjects: CoreMessage[];
            convertedTools: Record<string, CoreTool>;
            threadExists: boolean;
            thread: undefined;
            messageList: MessageList;
            agentAISpan: AISpan<AISpanType.AGENT_RUN> | undefined;
        } | {
            threadExists: boolean;
            tripwire?: boolean | undefined;
            tripwireReason?: string | undefined;
            convertedTools: Record<string, CoreTool>;
            thread: StorageThreadType;
            messageList: MessageList;
            messageObjects: CoreMessage[];
            agentAISpan: AISpan<AISpanType.AGENT_RUN> | undefined;
        }>;
        after: ({ result, thread: threadAfter, threadId, memoryConfig, outputText, runId, messageList, threadExists, structuredOutput, overrideScorers, agentAISpan, }: {
            runId: string;
            result: Record<string, any>;
            thread: StorageThreadType | null | undefined;
            threadId?: string;
            memoryConfig: MemoryConfig | undefined;
            outputText: string;
            messageList: MessageList;
            threadExists: boolean;
            structuredOutput?: boolean;
            overrideScorers?: MastraScorers;
            agentAISpan?: AISpan<AISpanType.AGENT_RUN>;
        }) => Promise<{
            scoringData: {
                input: Omit<ScorerRunInputForAgent, "runId">;
                output: ScorerRunOutputForAgent;
            };
        }>;
    };
    private resolveOverrideScorerReferences;
    private prepareLLMOptions;
    network(messages: MessageListInput, options?: MultiPrimitiveExecutionOptions): Promise<import("stream/web").ReadableStream<any>>;
    generateVNext<OUTPUT extends OutputSchema | undefined = undefined, STRUCTURED_OUTPUT extends ZodSchema | JSONSchema7 | undefined = undefined, FORMAT extends 'aisdk' | 'mastra' = 'mastra'>(messages: MessageListInput, options?: AgentExecutionOptions<OUTPUT, STRUCTURED_OUTPUT, FORMAT>): Promise<FORMAT extends 'aisdk' ? Awaited<ReturnType<AISDKV5OutputStream<OUTPUT>['getFullOutput']>> : Awaited<ReturnType<MastraModelOutput<OUTPUT>['getFullOutput']>>>;
    streamVNext<OUTPUT extends OutputSchema | undefined = undefined, STRUCTURED_OUTPUT extends ZodSchema | JSONSchema7 | undefined = undefined, FORMAT extends 'mastra' | 'aisdk' | undefined = undefined>(messages: MessageListInput, streamOptions?: AgentExecutionOptions<OUTPUT, STRUCTURED_OUTPUT, FORMAT>): Promise<FORMAT extends 'aisdk' ? AISDKV5OutputStream<OUTPUT> : MastraModelOutput<OUTPUT>>;
    generate(messages: MessageListInput, args?: AgentGenerateOptions<undefined, undefined> & {
        output?: never;
        experimental_output?: never;
    }): Promise<GenerateTextResult<any, undefined>>;
    generate<OUTPUT extends ZodSchema | JSONSchema7>(messages: MessageListInput, args?: AgentGenerateOptions<OUTPUT, undefined> & {
        output?: OUTPUT;
        experimental_output?: never;
    }): Promise<GenerateObjectResult<OUTPUT>>;
    generate<EXPERIMENTAL_OUTPUT extends ZodSchema | JSONSchema7>(messages: MessageListInput, args?: AgentGenerateOptions<undefined, EXPERIMENTAL_OUTPUT> & {
        output?: never;
        experimental_output?: EXPERIMENTAL_OUTPUT;
    }): Promise<GenerateTextResult<any, EXPERIMENTAL_OUTPUT>>;
    generateLegacy(messages: MessageListInput, args?: AgentGenerateOptions<undefined, undefined> & {
        output?: never;
        experimental_output?: never;
    }): Promise<GenerateTextResult<any, undefined>>;
    generateLegacy<OUTPUT extends ZodSchema | JSONSchema7>(messages: MessageListInput, args?: AgentGenerateOptions<OUTPUT, undefined> & {
        output?: OUTPUT;
        experimental_output?: never;
    }): Promise<GenerateObjectResult<OUTPUT>>;
    generateLegacy<EXPERIMENTAL_OUTPUT extends ZodSchema | JSONSchema7>(messages: MessageListInput, args?: AgentGenerateOptions<undefined, EXPERIMENTAL_OUTPUT> & {
        output?: never;
        experimental_output?: EXPERIMENTAL_OUTPUT;
    }): Promise<GenerateTextResult<any, EXPERIMENTAL_OUTPUT>>;
    stream<OUTPUT extends ZodSchema | JSONSchema7 | undefined = undefined, EXPERIMENTAL_OUTPUT extends ZodSchema | JSONSchema7 | undefined = undefined>(messages: MessageListInput, args?: AgentStreamOptions<OUTPUT, EXPERIMENTAL_OUTPUT> & {
        output?: never;
        experimental_output?: never;
    }): Promise<StreamTextResult<any, OUTPUT extends ZodSchema ? z.infer<OUTPUT> : unknown>>;
    stream<OUTPUT extends ZodSchema | JSONSchema7 | undefined = undefined, EXPERIMENTAL_OUTPUT extends ZodSchema | JSONSchema7 | undefined = undefined>(messages: MessageListInput, args?: AgentStreamOptions<OUTPUT, EXPERIMENTAL_OUTPUT> & {
        output?: OUTPUT;
        experimental_output?: never;
    }): Promise<StreamObjectResult<any, OUTPUT extends ZodSchema ? z.infer<OUTPUT> : unknown, any> & TracingProperties>;
    stream<OUTPUT extends ZodSchema | JSONSchema7 | undefined = undefined, EXPERIMENTAL_OUTPUT extends ZodSchema | JSONSchema7 | undefined = undefined>(messages: MessageListInput, args?: AgentStreamOptions<OUTPUT, EXPERIMENTAL_OUTPUT> & {
        output?: never;
        experimental_output?: EXPERIMENTAL_OUTPUT;
    }): Promise<StreamTextResult<any, OUTPUT extends ZodSchema ? z.infer<OUTPUT> : unknown> & {
        partialObjectStream: StreamTextResult<any, OUTPUT extends ZodSchema ? z.infer<OUTPUT> : EXPERIMENTAL_OUTPUT extends ZodSchema ? z.infer<EXPERIMENTAL_OUTPUT> : unknown>['experimental_partialOutputStream'];
    }>;
    streamLegacy<OUTPUT extends ZodSchema | JSONSchema7 | undefined = undefined, EXPERIMENTAL_OUTPUT extends ZodSchema | JSONSchema7 | undefined = undefined>(messages: MessageListInput, args?: AgentStreamOptions<OUTPUT, EXPERIMENTAL_OUTPUT> & {
        output?: never;
        experimental_output?: never;
    }): Promise<StreamTextResult<any, OUTPUT extends ZodSchema ? z.infer<OUTPUT> : unknown>>;
    streamLegacy<OUTPUT extends ZodSchema | JSONSchema7 | undefined = undefined, EXPERIMENTAL_OUTPUT extends ZodSchema | JSONSchema7 | undefined = undefined>(messages: MessageListInput, args?: AgentStreamOptions<OUTPUT, EXPERIMENTAL_OUTPUT> & {
        output?: OUTPUT;
        experimental_output?: never;
    }): Promise<StreamObjectResult<any, OUTPUT extends ZodSchema ? z.infer<OUTPUT> : unknown, any> & TracingProperties>;
    streamLegacy<OUTPUT extends ZodSchema | JSONSchema7 | undefined = undefined, EXPERIMENTAL_OUTPUT extends ZodSchema | JSONSchema7 | undefined = undefined>(messages: MessageListInput, args?: AgentStreamOptions<OUTPUT, EXPERIMENTAL_OUTPUT> & {
        output?: never;
        experimental_output?: EXPERIMENTAL_OUTPUT;
    }): Promise<StreamTextResult<any, OUTPUT extends ZodSchema ? z.infer<OUTPUT> : unknown> & {
        partialObjectStream: StreamTextResult<any, OUTPUT extends ZodSchema ? z.infer<OUTPUT> : EXPERIMENTAL_OUTPUT extends ZodSchema ? z.infer<EXPERIMENTAL_OUTPUT> : unknown>['experimental_partialOutputStream'];
    }>;
    /**
     * Convert text to speech using the configured voice provider
     * @param input Text or text stream to convert to speech
     * @param options Speech options including speaker and provider-specific options
     * @returns Audio stream
     * @deprecated Use agent.voice.speak() instead
     */
    speak(input: string | NodeJS.ReadableStream, options?: {
        speaker?: string;
        [key: string]: any;
    }): Promise<NodeJS.ReadableStream | void>;
    /**
     * Convert speech to text using the configured voice provider
     * @param audioStream Audio stream to transcribe
     * @param options Provider-specific transcription options
     * @returns Text or text stream
     * @deprecated Use agent.voice.listen() instead
     */
    listen(audioStream: NodeJS.ReadableStream, options?: {
        [key: string]: any;
    }): Promise<string | NodeJS.ReadableStream | void>;
    /**
     * Get a list of available speakers from the configured voice provider
     * @throws {Error} If no voice provider is configured
     * @returns {Promise<Array<{voiceId: string}>>} List of available speakers
     * @deprecated Use agent.voice.getSpeakers() instead
     */
    getSpeakers(): Promise<{
        voiceId: string;
    }[]>;
    toStep(): Step<TAgentId, z.ZodObject<{
        prompt: z.ZodString;
    }>, z.ZodObject<{
        text: z.ZodString;
    }>, any>;
    /**
     * Resolves the configuration for title generation.
     * @private
     */
    private resolveTitleGenerationConfig;
    /**
     * Resolves title generation instructions, handling both static strings and dynamic functions
     * @private
     */
    private resolveTitleInstructions;
}
//# sourceMappingURL=agent.d.ts.map