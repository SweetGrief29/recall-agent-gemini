import type { ReadableStream } from 'stream/web';
import z from 'zod';
import type { Agent } from '../../agent/index.js';
import { RuntimeContext } from '../../di/index.js';
import type { Mastra } from '../../mastra/index.js';
import { Tool } from '../../tools/index.js';
import type { ToolExecutionContext } from '../../tools/types.js';
import { Workflow, Run } from '../../workflows/index.js';
import type { ExecutionEngine, ExecutionGraph } from '../../workflows/execution-engine.js';
import type { ExecuteFunction, Step } from '../../workflows/step.js';
import type { SerializedStepFlowEntry, WorkflowConfig, WorkflowResult, StreamEvent, WatchEvent } from '../../workflows/types.js';
export type EventedEngineType = {};
export declare function cloneWorkflow<TWorkflowId extends string = string, TInput extends z.ZodType<any> = z.ZodType<any>, TOutput extends z.ZodType<any> = z.ZodType<any>, TSteps extends Step<string, any, any, any, any, EventedEngineType>[] = Step<string, any, any, any, any, EventedEngineType>[], TPrevSchema extends z.ZodType<any> = TInput>(workflow: Workflow<EventedEngineType, TSteps, string, TInput, TOutput, TPrevSchema>, opts: {
    id: TWorkflowId;
}): Workflow<EventedEngineType, TSteps, TWorkflowId, TInput, TOutput, TPrevSchema>;
export declare function cloneStep<TStepId extends string>(step: Step<string, any, any, any, any, EventedEngineType>, opts: {
    id: TStepId;
}): Step<TStepId, any, any, any, any, EventedEngineType>;
export declare function createStep<TStepId extends string, TStepInput extends z.ZodType<any>, TStepOutput extends z.ZodType<any>, TResumeSchema extends z.ZodType<any>, TSuspendSchema extends z.ZodType<any>>(params: {
    id: TStepId;
    description?: string;
    inputSchema: TStepInput;
    outputSchema: TStepOutput;
    resumeSchema?: TResumeSchema;
    suspendSchema?: TSuspendSchema;
    execute: ExecuteFunction<z.infer<TStepInput>, z.infer<TStepOutput>, z.infer<TResumeSchema>, z.infer<TSuspendSchema>, EventedEngineType>;
}): Step<TStepId, TStepInput, TStepOutput, TResumeSchema, TSuspendSchema, EventedEngineType>;
export declare function createStep<TStepId extends string, TStepInput extends z.ZodObject<{
    prompt: z.ZodString;
}>, TStepOutput extends z.ZodObject<{
    text: z.ZodString;
}>, TResumeSchema extends z.ZodType<any>, TSuspendSchema extends z.ZodType<any>>(agent: Agent<TStepId, any, any>): Step<TStepId, TStepInput, TStepOutput, TResumeSchema, TSuspendSchema, EventedEngineType>;
export declare function createStep<TSchemaIn extends z.ZodType<any>, TSchemaOut extends z.ZodType<any>, TContext extends ToolExecutionContext<TSchemaIn>>(tool: Tool<TSchemaIn, TSchemaOut, TContext> & {
    inputSchema: TSchemaIn;
    outputSchema: TSchemaOut;
    execute: (context: TContext) => Promise<any>;
}): Step<string, TSchemaIn, TSchemaOut, z.ZodType<any>, z.ZodType<any>, EventedEngineType>;
export declare function createWorkflow<TWorkflowId extends string = string, TInput extends z.ZodType<any> = z.ZodType<any>, TOutput extends z.ZodType<any> = z.ZodType<any>, TSteps extends Step<string, any, any, any, any, EventedEngineType>[] = Step<string, any, any, any, any, EventedEngineType>[]>(params: WorkflowConfig<TWorkflowId, TInput, TOutput, TSteps>): EventedWorkflow<EventedEngineType, TSteps, TWorkflowId, TInput, TOutput, TInput>;
export declare class EventedWorkflow<TEngineType = EventedEngineType, TSteps extends Step<string, any, any>[] = Step<string, any, any>[], TWorkflowId extends string = string, TInput extends z.ZodType<any> = z.ZodType<any>, TOutput extends z.ZodType<any> = z.ZodType<any>, TPrevSchema extends z.ZodType<any> = TInput> extends Workflow<TEngineType, TSteps, TWorkflowId, TInput, TOutput, TPrevSchema> {
    constructor(params: WorkflowConfig<TWorkflowId, TInput, TOutput, TSteps>);
    __registerMastra(mastra: Mastra): void;
    createRunAsync(options?: {
        runId?: string;
    }): Promise<Run<TEngineType, TSteps, TInput, TOutput>>;
}
export declare class EventedRun<TEngineType = EventedEngineType, TSteps extends Step<string, any, any>[] = Step<string, any, any>[], TInput extends z.ZodType<any> = z.ZodType<any>, TOutput extends z.ZodType<any> = z.ZodType<any>> extends Run<TEngineType, TSteps, TInput, TOutput> {
    constructor(params: {
        workflowId: string;
        runId: string;
        executionEngine: ExecutionEngine;
        executionGraph: ExecutionGraph;
        serializedStepGraph: SerializedStepFlowEntry[];
        mastra?: Mastra;
        retryConfig?: {
            attempts?: number;
            delay?: number;
        };
        cleanup?: () => void;
    });
    start({ inputData, runtimeContext, }: {
        inputData?: z.infer<TInput>;
        runtimeContext?: RuntimeContext;
    }): Promise<WorkflowResult<TOutput, TSteps>>;
    /**
     * Starts the workflow execution with the provided input as a stream
     * @param input The input data for the workflow
     * @returns A promise that resolves to the workflow output
     */
    stream({ inputData, runtimeContext }?: {
        inputData?: z.infer<TInput>;
        runtimeContext?: RuntimeContext;
    }): {
        stream: ReadableStream<StreamEvent>;
        getWorkflowState: () => Promise<WorkflowResult<TOutput, TSteps>>;
    };
    streamAsync({ inputData, runtimeContext, }?: {
        inputData?: z.infer<TInput>;
        runtimeContext?: RuntimeContext;
    }): Promise<{
        stream: ReadableStream<StreamEvent>;
        getWorkflowState: () => Promise<WorkflowResult<TOutput, TSteps>>;
    }>;
    resume<TResumeSchema extends z.ZodType<any>>(params: {
        resumeData?: z.infer<TResumeSchema>;
        step: Step<string, any, any, TResumeSchema, any, TEngineType> | [...Step<string, any, any, any, any, TEngineType>[], Step<string, any, any, TResumeSchema, any, TEngineType>] | string | string[];
        runtimeContext?: RuntimeContext;
    }): Promise<WorkflowResult<TOutput, TSteps>>;
    watch(cb: (event: WatchEvent) => void, type?: 'watch' | 'watch-v2'): () => void;
    watchAsync(cb: (event: WatchEvent) => void, type?: 'watch' | 'watch-v2'): Promise<() => Promise<void>>;
    cancel(): Promise<void>;
    sendEvent(eventName: string, data: any): Promise<void>;
}
//# sourceMappingURL=workflow.d.ts.map