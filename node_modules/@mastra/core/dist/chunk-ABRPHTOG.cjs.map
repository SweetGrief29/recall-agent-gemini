{"version":3,"sources":["../src/tools/validation.ts","../src/tools/tool.ts","../src/tools/toolchecks.ts"],"names":[],"mappings":"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","file":"chunk-ABRPHTOG.cjs","sourcesContent":["import type { z } from 'zod';\n\nexport interface ValidationError<T = any> {\n  error: true;\n  message: string;\n  validationErrors: z.ZodFormattedError<T>;\n}\n\n/**\n * Validates input against a Zod schema and returns a structured error if validation fails\n * @param schema The Zod schema to validate against\n * @param input The input to validate\n * @param toolId Optional tool ID for better error messages\n * @returns The validation error object if validation fails, undefined if successful\n */\nexport function validateToolInput<T = any>(\n  schema: z.ZodSchema<T> | undefined,\n  input: unknown,\n  toolId?: string,\n): { data: T | unknown; error?: ValidationError<T> } {\n  if (!schema || !('safeParse' in schema)) {\n    return { data: input };\n  }\n\n  // Store validation results to avoid duplicate validation\n  type ValidationAttempt = {\n    result: z.SafeParseReturnType<any, T>;\n    data: unknown;\n    structure: 'direct' | 'context' | 'inputData';\n  };\n\n  const validationAttempts: ValidationAttempt[] = [];\n\n  // Try validating the input directly first\n  const directValidation = schema.safeParse(input);\n  validationAttempts.push({\n    result: directValidation,\n    data: input,\n    structure: 'direct',\n  });\n\n  if (directValidation.success) {\n    return { data: input };\n  }\n\n  // Handle ToolExecutionContext format { context: data, ... }\n  if (input && typeof input === 'object' && 'context' in input) {\n    const contextData = (input as any).context;\n    const contextValidation = schema.safeParse(contextData);\n    validationAttempts.push({\n      result: contextValidation,\n      data: contextData,\n      structure: 'context',\n    });\n\n    if (contextValidation.success) {\n      return { data: { ...(input as object), context: contextValidation.data } };\n    }\n\n    // Handle StepExecutionContext format { context: { inputData: data, ... }, ... }\n    if (contextData && typeof contextData === 'object' && 'inputData' in contextData) {\n      const inputDataValue = (contextData as any).inputData;\n      const inputDataValidation = schema.safeParse(inputDataValue);\n      validationAttempts.push({\n        result: inputDataValidation,\n        data: inputDataValue,\n        structure: 'inputData',\n      });\n\n      if (inputDataValidation.success) {\n        // For inputData unwrapping, preserve the structure if the original context had additional properties\n        // but return just the validated data if it was a pure inputData wrapper\n        const contextKeys = Object.keys(contextData);\n\n        // If context only has inputData, return the full structure with the validated data\n        // Otherwise, return just the validated inputData\n        if (contextKeys.length === 1 && contextKeys[0] === 'inputData') {\n          return { data: { ...(input as object), context: { inputData: inputDataValidation.data } } };\n        } else {\n          // Multiple keys in context, return just the validated data\n          return { data: inputDataValidation.data };\n        }\n      }\n    }\n  }\n\n  // All validations failed, find the best error to return\n  // Prefer the most specific error (deepest unwrapping level that has meaningful errors)\n  let bestAttempt = validationAttempts[0]; // Start with direct validation\n\n  for (const attempt of validationAttempts) {\n    if (!attempt.result.success && attempt.result.error.issues.length > 0) {\n      bestAttempt = attempt;\n    }\n  }\n\n  // Use the best validation attempt for error reporting\n  if (bestAttempt && !bestAttempt.result.success) {\n    const errorMessages = bestAttempt.result.error.issues\n      .map((e: z.ZodIssue) => `- ${e.path?.join('.') || 'root'}: ${e.message}`)\n      .join('\\n');\n\n    const error: ValidationError<T> = {\n      error: true,\n      message: `Tool validation failed${toolId ? ` for ${toolId}` : ''}. Please fix the following errors and try again:\\n${errorMessages}\\n\\nProvided arguments: ${JSON.stringify(bestAttempt.data, null, 2)}`,\n      validationErrors: bestAttempt.result.error.format() as z.ZodFormattedError<T>,\n    };\n\n    return { data: input, error };\n  }\n\n  // This should not happen since we handle all valid cases above\n  return { data: input };\n}\n","import type { ToolExecutionOptions } from 'ai';\nimport type { ToolCallOptions } from 'ai-v5';\nimport type { z } from 'zod';\n\nimport type { Mastra } from '../mastra';\nimport type { ToolAction, ToolExecutionContext } from './types';\nimport { validateToolInput } from './validation';\n\nexport class Tool<\n  TSchemaIn extends z.ZodSchema | undefined = undefined,\n  TSchemaOut extends z.ZodSchema | undefined = undefined,\n  TContext extends ToolExecutionContext<TSchemaIn> = ToolExecutionContext<TSchemaIn>,\n> implements ToolAction<TSchemaIn, TSchemaOut, TContext>\n{\n  id: string;\n  description: string;\n  inputSchema?: TSchemaIn;\n  outputSchema?: TSchemaOut;\n  execute?: ToolAction<TSchemaIn, TSchemaOut, TContext>['execute'];\n  mastra?: Mastra;\n\n  constructor(opts: ToolAction<TSchemaIn, TSchemaOut, TContext>) {\n    this.id = opts.id;\n    this.description = opts.description;\n    this.inputSchema = opts.inputSchema;\n    this.outputSchema = opts.outputSchema;\n    this.mastra = opts.mastra;\n\n    // Wrap the execute function with validation if it exists\n    if (opts.execute) {\n      const originalExecute = opts.execute;\n      this.execute = async (context: TContext, options?: ToolExecutionOptions) => {\n        // Validate input if schema exists\n        const { data, error } = validateToolInput(this.inputSchema, context, this.id);\n        if (error) {\n          return error as any;\n        }\n\n        return originalExecute(data as TContext, options);\n      };\n    }\n  }\n}\n\nexport function createTool<\n  TSchemaIn extends z.ZodSchema | undefined = undefined,\n  TSchemaOut extends z.ZodSchema | undefined = undefined,\n  TContext extends ToolExecutionContext<TSchemaIn> = ToolExecutionContext<TSchemaIn>,\n  TExecute extends ToolAction<TSchemaIn, TSchemaOut, TContext>['execute'] = ToolAction<\n    TSchemaIn,\n    TSchemaOut,\n    TContext\n  >['execute'],\n>(\n  opts: ToolAction<TSchemaIn, TSchemaOut, TContext> & {\n    execute?: TExecute;\n  },\n): [TSchemaIn, TSchemaOut, TExecute] extends [z.ZodSchema, z.ZodSchema, Function]\n  ? Tool<TSchemaIn, TSchemaOut, TContext> & {\n      inputSchema: TSchemaIn;\n      outputSchema: TSchemaOut;\n      execute: (context: TContext, options: ToolExecutionOptions | ToolCallOptions) => Promise<any>;\n    }\n  : Tool<TSchemaIn, TSchemaOut, TContext> {\n  return new Tool(opts) as any;\n}\n","import { Tool } from './tool';\nimport type { ToolToConvert } from './tool-builder/builder';\nimport type { VercelTool } from './types';\n\n/**\n * Checks if a tool is a Vercel Tool\n * @param tool - The tool to check\n * @returns True if the tool is a Vercel Tool, false otherwise\n */\nexport function isVercelTool(tool?: ToolToConvert): tool is VercelTool {\n  // Checks if this tool is not an instance of Tool\n  return !!(tool && !(tool instanceof Tool) && 'parameters' in tool);\n}\n"]}