import type { RuntimeContext } from '@mastra/core/di';
import type { MastraMemory } from '@mastra/core/memory';
import type { StorageGetMessagesArg, ThreadSortOptions } from '@mastra/core/storage';
import type { Context } from '../types.js';
import { handleError } from './error.js';
interface MemoryContext extends Context {
    agentId?: string;
    resourceId?: string;
    threadId?: string;
    networkId?: string;
    runtimeContext?: RuntimeContext;
}
export declare function getMemoryStatusHandler({ mastra, agentId, networkId, runtimeContext, }: Pick<MemoryContext, 'mastra' | 'agentId' | 'networkId' | 'runtimeContext'>): Promise<{
    result: boolean;
}>;
export declare function getMemoryConfigHandler({ mastra, agentId, networkId, runtimeContext, }: Pick<MemoryContext, 'mastra' | 'agentId' | 'networkId' | 'runtimeContext'>): Promise<{
    config: import("@mastra/core").MemoryConfig;
}>;
export declare function getThreadsHandler({ mastra, agentId, resourceId, networkId, runtimeContext, orderBy, sortDirection, }: Pick<MemoryContext, 'mastra' | 'agentId' | 'resourceId' | 'networkId' | 'runtimeContext'> & ThreadSortOptions): Promise<import("@mastra/core").StorageThreadType[]>;
export declare function getThreadsPaginatedHandler({ mastra, agentId, resourceId, networkId, runtimeContext, page, perPage, orderBy, sortDirection, }: Pick<MemoryContext, 'mastra' | 'agentId' | 'resourceId' | 'networkId' | 'runtimeContext'> & {
    page: number;
    perPage: number;
} & ThreadSortOptions): Promise<import("@mastra/core").PaginationInfo & {
    threads: import("@mastra/core").StorageThreadType[];
}>;
export declare function getThreadByIdHandler({ mastra, agentId, threadId, networkId, runtimeContext, }: Pick<MemoryContext, 'mastra' | 'agentId' | 'threadId' | 'networkId' | 'runtimeContext'>): Promise<import("@mastra/core").StorageThreadType>;
export declare function saveMessagesHandler({ mastra, agentId, body, networkId, runtimeContext, }: Pick<MemoryContext, 'mastra' | 'agentId' | 'networkId' | 'runtimeContext'> & {
    body: {
        messages: Parameters<MastraMemory['saveMessages']>[0]['messages'];
    };
}): Promise<import("@mastra/core").MastraMessageV1[]>;
export declare function createThreadHandler({ mastra, agentId, body, networkId, runtimeContext, }: Pick<MemoryContext, 'mastra' | 'agentId' | 'networkId' | 'runtimeContext'> & {
    body?: Omit<Parameters<MastraMemory['createThread']>[0], 'resourceId'> & {
        resourceId?: string;
    };
}): Promise<import("@mastra/core").StorageThreadType>;
export declare function updateThreadHandler({ mastra, agentId, threadId, body, networkId, runtimeContext, }: Pick<MemoryContext, 'mastra' | 'agentId' | 'threadId' | 'networkId' | 'runtimeContext'> & {
    body?: Parameters<MastraMemory['saveThread']>[0]['thread'];
}): Promise<import("@mastra/core").StorageThreadType>;
export declare function deleteThreadHandler({ mastra, agentId, threadId, networkId, runtimeContext, }: Pick<MemoryContext, 'mastra' | 'agentId' | 'threadId' | 'networkId' | 'runtimeContext'>): Promise<{
    result: string;
}>;
export declare function getMessagesPaginatedHandler({ mastra, threadId, resourceId, selectBy, format, }: StorageGetMessagesArg & Pick<MemoryContext, 'mastra'>): Promise<import("@mastra/core").PaginationInfo & {
    messages: import("@mastra/core").MastraMessageV1[] | import("@mastra/core").MastraMessageV2[];
}>;
export declare function getMessagesHandler({ mastra, agentId, threadId, limit, networkId, runtimeContext, }: Pick<MemoryContext, 'mastra' | 'agentId' | 'threadId' | 'networkId' | 'runtimeContext'> & {
    limit?: number;
}): Promise<{
    messages: import("ai").CoreMessage[];
    uiMessages: import("@mastra/core/agent").UIMessageWithMetadata[];
}>;
/**
 * Handler to get the working memory for a thread (optionally resource-scoped).
 * @returns workingMemory - the working memory for the thread
 * @returns source - thread or resource
 */
export declare function getWorkingMemoryHandler({ mastra, agentId, threadId, resourceId, networkId, runtimeContext, memoryConfig, }: Pick<MemoryContext, 'mastra' | 'agentId' | 'threadId' | 'networkId' | 'runtimeContext'> & {
    resourceId?: Parameters<MastraMemory['getWorkingMemory']>[0]['resourceId'];
    memoryConfig?: Parameters<MastraMemory['getWorkingMemory']>[0]['memoryConfig'];
}): Promise<{
    workingMemory: string | null;
    source: string;
    workingMemoryTemplate: import("@mastra/core").WorkingMemoryTemplate | null;
    threadExists: boolean;
}>;
/**
 * Handler to update the working memory for a thread (optionally resource-scoped).
 * @param threadId - the thread id
 * @param body - the body containing the working memory to update and the resource id (optional)
 */
export declare function updateWorkingMemoryHandler({ mastra, agentId, threadId, body, networkId, runtimeContext, }: Pick<MemoryContext, 'mastra' | 'agentId' | 'threadId' | 'networkId' | 'runtimeContext'> & {
    body: Omit<Parameters<MastraMemory['updateWorkingMemory']>[0], 'threadId'>;
}): Promise<{
    success: boolean;
}>;
interface SearchResult {
    id: string;
    role: string;
    content: any;
    createdAt: Date;
    threadId?: string;
    threadTitle?: string;
    score?: number;
    context?: {
        before?: SearchResult[];
        after?: SearchResult[];
    };
}
interface SearchResponse {
    results: SearchResult[];
    count: number;
    query: string;
    searchScope?: string;
    searchType?: string;
}
/**
 * Handler to delete one or more messages.
 * @param messageIds - Can be a single ID, array of IDs, or objects with ID property
 */
export declare function deleteMessagesHandler({ mastra, agentId, messageIds, networkId, runtimeContext, }: Pick<MemoryContext, 'mastra' | 'agentId' | 'networkId' | 'runtimeContext'> & {
    messageIds: string | string[] | {
        id: string;
    } | {
        id: string;
    }[];
}): Promise<{
    success: boolean;
    message: string;
}>;
export declare function searchMemoryHandler({ mastra, agentId, searchQuery, resourceId, threadId, limit, networkId, runtimeContext, memoryConfig, }: Pick<MemoryContext, 'mastra' | 'agentId' | 'networkId' | 'runtimeContext'> & {
    searchQuery: string;
    resourceId: string;
    threadId?: string;
    limit?: number;
    memoryConfig?: any;
}): Promise<SearchResponse | ReturnType<typeof handleError>>;
export {};
//# sourceMappingURL=memory.d.ts.map