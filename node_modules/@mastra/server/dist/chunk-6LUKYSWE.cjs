'use strict';

var chunkGU4EWMZB_cjs = require('./chunk-GU4EWMZB.cjs');
var chunkRE4RPXT2_cjs = require('./chunk-RE4RPXT2.cjs');
var chunk7NADHFD2_cjs = require('./chunk-7NADHFD2.cjs');
var chunkEMMSS5I5_cjs = require('./chunk-EMMSS5I5.cjs');
var web = require('stream/web');
var zodToJson = require('@mastra/core/utils/zod-to-json');

// src/server/handlers/workflows.ts
var workflows_exports = {};
chunkEMMSS5I5_cjs.__export(workflows_exports, {
  cancelWorkflowRunHandler: () => cancelWorkflowRunHandler,
  createWorkflowRunHandler: () => createWorkflowRunHandler,
  getWorkflowByIdHandler: () => getWorkflowByIdHandler,
  getWorkflowRunByIdHandler: () => getWorkflowRunByIdHandler,
  getWorkflowRunExecutionResultHandler: () => getWorkflowRunExecutionResultHandler,
  getWorkflowRunsHandler: () => getWorkflowRunsHandler,
  getWorkflowsHandler: () => getWorkflowsHandler,
  resumeAsyncWorkflowHandler: () => resumeAsyncWorkflowHandler,
  resumeWorkflowHandler: () => resumeWorkflowHandler,
  sendWorkflowRunEventHandler: () => sendWorkflowRunEventHandler,
  startAsyncWorkflowHandler: () => startAsyncWorkflowHandler,
  startWorkflowRunHandler: () => startWorkflowRunHandler,
  streamVNextWorkflowHandler: () => streamVNextWorkflowHandler,
  streamWorkflowHandler: () => streamWorkflowHandler,
  watchWorkflowHandler: () => watchWorkflowHandler
});
function getSteps(steps, path) {
  return Object.entries(steps).reduce((acc, [key, step]) => {
    const fullKey = path ? `${path}.${key}` : key;
    acc[fullKey] = {
      id: step.id,
      description: step.description,
      inputSchema: step.inputSchema ? chunkGU4EWMZB_cjs.stringify(zodToJson.zodToJsonSchema(step.inputSchema)) : void 0,
      outputSchema: step.outputSchema ? chunkGU4EWMZB_cjs.stringify(zodToJson.zodToJsonSchema(step.outputSchema)) : void 0,
      resumeSchema: step.resumeSchema ? chunkGU4EWMZB_cjs.stringify(zodToJson.zodToJsonSchema(step.resumeSchema)) : void 0,
      suspendSchema: step.suspendSchema ? chunkGU4EWMZB_cjs.stringify(zodToJson.zodToJsonSchema(step.suspendSchema)) : void 0,
      isWorkflow: step.component === "WORKFLOW"
    };
    if (step.component === "WORKFLOW" && step.steps) {
      const nestedSteps = getSteps(step.steps, fullKey) || {};
      acc = { ...acc, ...nestedSteps };
    }
    return acc;
  }, {});
}
function getWorkflowInfo(workflow) {
  return {
    name: workflow.name,
    description: workflow.description,
    steps: Object.entries(workflow.steps).reduce((acc, [key, step]) => {
      acc[key] = {
        id: step.id,
        description: step.description,
        inputSchema: step.inputSchema ? chunkGU4EWMZB_cjs.stringify(zodToJson.zodToJsonSchema(step.inputSchema)) : void 0,
        outputSchema: step.outputSchema ? chunkGU4EWMZB_cjs.stringify(zodToJson.zodToJsonSchema(step.outputSchema)) : void 0,
        resumeSchema: step.resumeSchema ? chunkGU4EWMZB_cjs.stringify(zodToJson.zodToJsonSchema(step.resumeSchema)) : void 0,
        suspendSchema: step.suspendSchema ? chunkGU4EWMZB_cjs.stringify(zodToJson.zodToJsonSchema(step.suspendSchema)) : void 0
      };
      return acc;
    }, {}),
    allSteps: getSteps(workflow.steps) || {},
    stepGraph: workflow.serializedStepGraph,
    inputSchema: workflow.inputSchema ? chunkGU4EWMZB_cjs.stringify(zodToJson.zodToJsonSchema(workflow.inputSchema)) : void 0,
    outputSchema: workflow.outputSchema ? chunkGU4EWMZB_cjs.stringify(zodToJson.zodToJsonSchema(workflow.outputSchema)) : void 0
  };
}
var WorkflowRegistry = class {
  static additionalWorkflows = {};
  /**
   * Register a workflow temporarily
   */
  static registerTemporaryWorkflow(id, workflow) {
    this.additionalWorkflows[id] = workflow;
  }
  /**
   * Register all workflows from map
   */
  static registerTemporaryWorkflows(workflows, mastra) {
    for (const [id, workflow] of Object.entries(workflows)) {
      if (mastra) {
        workflow.__registerMastra(mastra);
        workflow.__registerPrimitives({
          logger: mastra.getLogger(),
          telemetry: mastra.getTelemetry(),
          storage: mastra.getStorage(),
          memory: mastra.getMemory(),
          agents: mastra.getAgents(),
          tts: mastra.getTTS(),
          vectors: mastra.getVectors()
        });
      }
      this.additionalWorkflows[id] = workflow;
    }
  }
  /**
   * Get a workflow by ID from the registry (returns undefined if not found)
   */
  static getWorkflow(workflowId) {
    return this.additionalWorkflows[workflowId];
  }
  /**
   * Get all workflows from the registry
   */
  static getAllWorkflows() {
    return { ...this.additionalWorkflows };
  }
  /**
   * Clean up a temporary workflow
   */
  static cleanupTemporaryWorkflow(workflowId) {
    delete this.additionalWorkflows[workflowId];
  }
  /**
   * Clean up all registered workflows
   */
  static cleanup() {
    this.additionalWorkflows = {};
  }
  /**
   * Check if a workflow ID is a valid agent-builder workflow
   */
  static isAgentBuilderWorkflow(workflowId) {
    return workflowId in this.additionalWorkflows;
  }
  /**
   * Get all registered temporary workflow IDs (for debugging)
   */
  static getRegisteredWorkflowIds() {
    return Object.keys(this.additionalWorkflows);
  }
};

// src/server/handlers/workflows.ts
async function getWorkflowsHandler({ mastra }) {
  try {
    const workflows = mastra.getWorkflows({ serialized: false });
    const _workflows = Object.entries(workflows).reduce((acc, [key, workflow]) => {
      acc[key] = getWorkflowInfo(workflow);
      return acc;
    }, {});
    return _workflows;
  } catch (error) {
    return chunkRE4RPXT2_cjs.handleError(error, "Error getting workflows");
  }
}
async function getWorkflowsFromSystem({ mastra, workflowId }) {
  const logger = mastra.getLogger();
  if (!workflowId) {
    throw new chunk7NADHFD2_cjs.HTTPException(400, { message: "Workflow ID is required" });
  }
  let workflow;
  workflow = WorkflowRegistry.getWorkflow(workflowId);
  if (!workflow) {
    try {
      workflow = mastra.getWorkflow(workflowId);
    } catch (error) {
      logger.debug("Error getting workflow, searching agents for workflow", error);
    }
  }
  if (!workflow) {
    logger.debug("Workflow not found, searching agents for workflow", { workflowId });
    const agents = mastra.getAgents();
    if (Object.keys(agents || {}).length) {
      for (const [_, agent] of Object.entries(agents)) {
        try {
          const workflows = await agent.getWorkflows();
          if (workflows[workflowId]) {
            workflow = workflows[workflowId];
            break;
          }
          break;
        } catch (error) {
          logger.debug("Error getting workflow from agent", error);
        }
      }
    }
  }
  if (!workflow) {
    throw new chunk7NADHFD2_cjs.HTTPException(404, { message: "Workflow not found" });
  }
  return { workflow };
}
async function getWorkflowByIdHandler({ mastra, workflowId }) {
  try {
    if (!workflowId) {
      throw new chunk7NADHFD2_cjs.HTTPException(400, { message: "Workflow ID is required" });
    }
    const { workflow } = await getWorkflowsFromSystem({ mastra, workflowId });
    if (!workflow) {
      throw new chunk7NADHFD2_cjs.HTTPException(404, { message: "Workflow not found" });
    }
    return getWorkflowInfo(workflow);
  } catch (error) {
    return chunkRE4RPXT2_cjs.handleError(error, "Error getting workflow");
  }
}
async function getWorkflowRunByIdHandler({
  mastra,
  workflowId,
  runId
}) {
  try {
    if (!workflowId) {
      throw new chunk7NADHFD2_cjs.HTTPException(400, { message: "Workflow ID is required" });
    }
    if (!runId) {
      throw new chunk7NADHFD2_cjs.HTTPException(400, { message: "Run ID is required" });
    }
    const { workflow } = await getWorkflowsFromSystem({ mastra, workflowId });
    if (!workflow) {
      throw new chunk7NADHFD2_cjs.HTTPException(404, { message: "Workflow not found" });
    }
    const run = await workflow.getWorkflowRunById(runId);
    if (!run) {
      throw new chunk7NADHFD2_cjs.HTTPException(404, { message: "Workflow run not found" });
    }
    return run;
  } catch (error) {
    return chunkRE4RPXT2_cjs.handleError(error, "Error getting workflow run");
  }
}
async function getWorkflowRunExecutionResultHandler({
  mastra,
  workflowId,
  runId
}) {
  try {
    if (!workflowId) {
      throw new chunk7NADHFD2_cjs.HTTPException(400, { message: "Workflow ID is required" });
    }
    if (!runId) {
      throw new chunk7NADHFD2_cjs.HTTPException(400, { message: "Run ID is required" });
    }
    const workflow = mastra.getWorkflow(workflowId);
    if (!workflow) {
      throw new chunk7NADHFD2_cjs.HTTPException(404, { message: "Workflow not found" });
    }
    const executionResult = await workflow.getWorkflowRunExecutionResult(runId);
    if (!executionResult) {
      throw new chunk7NADHFD2_cjs.HTTPException(404, { message: "Workflow run execution result not found" });
    }
    return executionResult;
  } catch (error) {
    return chunkRE4RPXT2_cjs.handleError(error, "Error getting workflow run execution result");
  }
}
async function createWorkflowRunHandler({
  mastra,
  workflowId,
  runId: prevRunId
}) {
  try {
    if (!workflowId) {
      throw new chunk7NADHFD2_cjs.HTTPException(400, { message: "Workflow ID is required" });
    }
    const { workflow } = await getWorkflowsFromSystem({ mastra, workflowId });
    if (!workflow) {
      throw new chunk7NADHFD2_cjs.HTTPException(404, { message: "Workflow not found" });
    }
    const run = await workflow.createRunAsync({ runId: prevRunId });
    return { runId: run.runId };
  } catch (error) {
    return chunkRE4RPXT2_cjs.handleError(error, "Error creating workflow run");
  }
}
async function startAsyncWorkflowHandler({
  mastra,
  runtimeContext,
  workflowId,
  runId,
  inputData
}) {
  try {
    if (!workflowId) {
      throw new chunk7NADHFD2_cjs.HTTPException(400, { message: "Workflow ID is required" });
    }
    const { workflow } = await getWorkflowsFromSystem({ mastra, workflowId });
    if (!workflow) {
      throw new chunk7NADHFD2_cjs.HTTPException(404, { message: "Workflow not found" });
    }
    const _run = await workflow.createRunAsync({ runId });
    const result = await _run.start({
      inputData,
      runtimeContext
    });
    return result;
  } catch (error) {
    return chunkRE4RPXT2_cjs.handleError(error, "Error starting async workflow");
  }
}
async function startWorkflowRunHandler({
  mastra,
  runtimeContext,
  workflowId,
  runId,
  inputData
}) {
  try {
    if (!workflowId) {
      throw new chunk7NADHFD2_cjs.HTTPException(400, { message: "Workflow ID is required" });
    }
    if (!runId) {
      throw new chunk7NADHFD2_cjs.HTTPException(400, { message: "runId required to start run" });
    }
    const { workflow } = await getWorkflowsFromSystem({ mastra, workflowId });
    if (!workflow) {
      throw new chunk7NADHFD2_cjs.HTTPException(404, { message: "Workflow not found" });
    }
    const run = await workflow.getWorkflowRunById(runId);
    if (!run) {
      throw new chunk7NADHFD2_cjs.HTTPException(404, { message: "Workflow run not found" });
    }
    const _run = await workflow.createRunAsync({ runId });
    void _run.start({
      inputData,
      runtimeContext
    });
    return { message: "Workflow run started" };
  } catch (e) {
    return chunkRE4RPXT2_cjs.handleError(e, "Error starting workflow run");
  }
}
async function watchWorkflowHandler({
  mastra,
  workflowId,
  runId,
  eventType = "watch"
}) {
  try {
    if (!workflowId) {
      throw new chunk7NADHFD2_cjs.HTTPException(400, { message: "Workflow ID is required" });
    }
    if (!runId) {
      throw new chunk7NADHFD2_cjs.HTTPException(400, { message: "runId required to watch workflow" });
    }
    const { workflow } = await getWorkflowsFromSystem({ mastra, workflowId });
    if (!workflow) {
      throw new chunk7NADHFD2_cjs.HTTPException(404, { message: "Workflow not found" });
    }
    const run = await workflow.getWorkflowRunById(runId);
    if (!run) {
      throw new chunk7NADHFD2_cjs.HTTPException(404, { message: "Workflow run not found" });
    }
    const _run = await workflow.createRunAsync({ runId });
    let unwatch;
    let asyncRef = null;
    const stream = new web.ReadableStream({
      start(controller) {
        unwatch = _run.watch((event) => {
          const { type, payload, eventTimestamp } = event;
          controller.enqueue(JSON.stringify({ type, payload, eventTimestamp, runId }));
          if (asyncRef) {
            clearImmediate(asyncRef);
            asyncRef = null;
          }
          asyncRef = setImmediate(async () => {
            const runDone = eventType === "watch" ? payload.workflowState.status !== "running" : type === "finish";
            if (runDone) {
              controller.close();
              unwatch?.();
            }
          });
        }, eventType);
      },
      cancel() {
        if (asyncRef) {
          clearImmediate(asyncRef);
          asyncRef = null;
        }
        unwatch?.();
      }
    });
    return stream;
  } catch (error) {
    return chunkRE4RPXT2_cjs.handleError(error, "Error watching workflow");
  }
}
async function streamWorkflowHandler({
  mastra,
  runtimeContext,
  workflowId,
  runId,
  inputData
}) {
  try {
    if (!workflowId) {
      throw new chunk7NADHFD2_cjs.HTTPException(400, { message: "Workflow ID is required" });
    }
    if (!runId) {
      throw new chunk7NADHFD2_cjs.HTTPException(400, { message: "runId required to resume workflow" });
    }
    const { workflow } = await getWorkflowsFromSystem({ mastra, workflowId });
    if (!workflow) {
      throw new chunk7NADHFD2_cjs.HTTPException(404, { message: "Workflow not found" });
    }
    const run = await workflow.createRunAsync({ runId });
    const result = run.stream({
      inputData,
      runtimeContext
    });
    return result;
  } catch (error) {
    return chunkRE4RPXT2_cjs.handleError(error, "Error executing workflow");
  }
}
async function streamVNextWorkflowHandler({
  mastra,
  runtimeContext,
  workflowId,
  runId,
  inputData
}) {
  try {
    if (!workflowId) {
      throw new chunk7NADHFD2_cjs.HTTPException(400, { message: "Workflow ID is required" });
    }
    if (!runId) {
      throw new chunk7NADHFD2_cjs.HTTPException(400, { message: "runId required to stream workflow" });
    }
    const { workflow } = await getWorkflowsFromSystem({ mastra, workflowId });
    if (!workflow) {
      throw new chunk7NADHFD2_cjs.HTTPException(404, { message: "Workflow not found" });
    }
    const run = await workflow.createRunAsync({ runId });
    const result = run.streamVNext({
      inputData,
      runtimeContext
    });
    return result;
  } catch (error) {
    return chunkRE4RPXT2_cjs.handleError(error, "Error streaming workflow");
  }
}
async function resumeAsyncWorkflowHandler({
  mastra,
  workflowId,
  runId,
  body,
  runtimeContext
}) {
  try {
    if (!workflowId) {
      throw new chunk7NADHFD2_cjs.HTTPException(400, { message: "Workflow ID is required" });
    }
    if (!runId) {
      throw new chunk7NADHFD2_cjs.HTTPException(400, { message: "runId required to resume workflow" });
    }
    if (!body.step) {
      throw new chunk7NADHFD2_cjs.HTTPException(400, { message: "step required to resume workflow" });
    }
    const { workflow } = await getWorkflowsFromSystem({ mastra, workflowId });
    if (!workflow) {
      throw new chunk7NADHFD2_cjs.HTTPException(404, { message: "Workflow not found" });
    }
    const run = await workflow.getWorkflowRunById(runId);
    if (!run) {
      throw new chunk7NADHFD2_cjs.HTTPException(404, { message: "Workflow run not found" });
    }
    const _run = await workflow.createRunAsync({ runId });
    const result = await _run.resume({
      step: body.step,
      resumeData: body.resumeData,
      runtimeContext
    });
    return result;
  } catch (error) {
    return chunkRE4RPXT2_cjs.handleError(error, "Error resuming workflow step");
  }
}
async function resumeWorkflowHandler({
  mastra,
  workflowId,
  runId,
  body,
  runtimeContext
}) {
  try {
    if (!workflowId) {
      throw new chunk7NADHFD2_cjs.HTTPException(400, { message: "Workflow ID is required" });
    }
    if (!runId) {
      throw new chunk7NADHFD2_cjs.HTTPException(400, { message: "runId required to resume workflow" });
    }
    if (!body.step) {
      throw new chunk7NADHFD2_cjs.HTTPException(400, { message: "step required to resume workflow" });
    }
    const { workflow } = await getWorkflowsFromSystem({ mastra, workflowId });
    if (!workflow) {
      throw new chunk7NADHFD2_cjs.HTTPException(404, { message: "Workflow not found" });
    }
    const run = await workflow.getWorkflowRunById(runId);
    if (!run) {
      throw new chunk7NADHFD2_cjs.HTTPException(404, { message: "Workflow run not found" });
    }
    const _run = await workflow.createRunAsync({ runId });
    void _run.resume({
      step: body.step,
      resumeData: body.resumeData,
      runtimeContext
    });
    return { message: "Workflow run resumed" };
  } catch (error) {
    return chunkRE4RPXT2_cjs.handleError(error, "Error resuming workflow");
  }
}
async function getWorkflowRunsHandler({
  mastra,
  workflowId,
  fromDate,
  toDate,
  limit,
  offset,
  resourceId
}) {
  try {
    if (!workflowId) {
      throw new chunk7NADHFD2_cjs.HTTPException(400, { message: "Workflow ID is required" });
    }
    const { workflow } = await getWorkflowsFromSystem({ mastra, workflowId });
    if (!workflow) {
      throw new chunk7NADHFD2_cjs.HTTPException(404, { message: "Workflow not found" });
    }
    const workflowRuns = await workflow.getWorkflowRuns({ fromDate, toDate, limit, offset, resourceId }) || {
      runs: [],
      total: 0
    };
    return workflowRuns;
  } catch (error) {
    return chunkRE4RPXT2_cjs.handleError(error, "Error getting workflow runs");
  }
}
async function cancelWorkflowRunHandler({
  mastra,
  workflowId,
  runId
}) {
  try {
    if (!workflowId) {
      throw new chunk7NADHFD2_cjs.HTTPException(400, { message: "Workflow ID is required" });
    }
    if (!runId) {
      throw new chunk7NADHFD2_cjs.HTTPException(400, { message: "runId required to cancel workflow run" });
    }
    const { workflow } = await getWorkflowsFromSystem({ mastra, workflowId });
    if (!workflow) {
      throw new chunk7NADHFD2_cjs.HTTPException(404, { message: "Workflow not found" });
    }
    const run = await workflow.getWorkflowRunById(runId);
    if (!run) {
      throw new chunk7NADHFD2_cjs.HTTPException(404, { message: "Workflow run not found" });
    }
    const _run = await workflow.createRunAsync({ runId });
    await _run.cancel();
    return { message: "Workflow run cancelled" };
  } catch (error) {
    return chunkRE4RPXT2_cjs.handleError(error, "Error canceling workflow run");
  }
}
async function sendWorkflowRunEventHandler({
  mastra,
  workflowId,
  runId,
  event,
  data
}) {
  try {
    if (!workflowId) {
      throw new chunk7NADHFD2_cjs.HTTPException(400, { message: "Workflow ID is required" });
    }
    if (!runId) {
      throw new chunk7NADHFD2_cjs.HTTPException(400, { message: "runId required to send workflow run event" });
    }
    const { workflow } = await getWorkflowsFromSystem({ mastra, workflowId });
    if (!workflow) {
      throw new chunk7NADHFD2_cjs.HTTPException(404, { message: "Workflow not found" });
    }
    const run = await workflow.getWorkflowRunById(runId);
    if (!run) {
      throw new chunk7NADHFD2_cjs.HTTPException(404, { message: "Workflow run not found" });
    }
    const _run = await workflow.createRunAsync({ runId });
    await _run.sendEvent(event, data);
    return { message: "Workflow run event sent" };
  } catch (error) {
    return chunkRE4RPXT2_cjs.handleError(error, "Error sending workflow run event");
  }
}

exports.WorkflowRegistry = WorkflowRegistry;
exports.cancelWorkflowRunHandler = cancelWorkflowRunHandler;
exports.createWorkflowRunHandler = createWorkflowRunHandler;
exports.getWorkflowByIdHandler = getWorkflowByIdHandler;
exports.getWorkflowInfo = getWorkflowInfo;
exports.getWorkflowRunByIdHandler = getWorkflowRunByIdHandler;
exports.getWorkflowRunExecutionResultHandler = getWorkflowRunExecutionResultHandler;
exports.getWorkflowRunsHandler = getWorkflowRunsHandler;
exports.getWorkflowsHandler = getWorkflowsHandler;
exports.resumeAsyncWorkflowHandler = resumeAsyncWorkflowHandler;
exports.resumeWorkflowHandler = resumeWorkflowHandler;
exports.sendWorkflowRunEventHandler = sendWorkflowRunEventHandler;
exports.startAsyncWorkflowHandler = startAsyncWorkflowHandler;
exports.startWorkflowRunHandler = startWorkflowRunHandler;
exports.streamVNextWorkflowHandler = streamVNextWorkflowHandler;
exports.streamWorkflowHandler = streamWorkflowHandler;
exports.watchWorkflowHandler = watchWorkflowHandler;
exports.workflows_exports = workflows_exports;
//# sourceMappingURL=chunk-6LUKYSWE.cjs.map
//# sourceMappingURL=chunk-6LUKYSWE.cjs.map