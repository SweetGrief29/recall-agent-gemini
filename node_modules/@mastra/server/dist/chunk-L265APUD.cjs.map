{"version":3,"sources":["../src/server/handlers/observability.ts"],"names":["__export","HTTPException","handleError"],"mappings":";;;;;;;AAAA,IAAA,qBAAA,GAAA;AAAAA,0BAAA,CAAA,qBAAA,EAAA;AAAA,EAAA,iBAAA,EAAA,MAAA,iBAAA;AAAA,EAAA,2BAAA,EAAA,MAAA;AAAA,CAAA,CAAA;AAeA,eAAsB,iBAAA,CAAkB,EAAE,MAAA,EAAQ,OAAA,EAAQ,EAA+C;AACvG,EAAA,IAAI;AACF,IAAA,IAAI,CAAC,OAAA,EAAS;AACZ,MAAA,MAAM,IAAIC,+BAAA,CAAc,GAAA,EAAK,EAAE,OAAA,EAAS,wBAAwB,CAAA;AAAA,IAClE;AAEA,IAAA,MAAM,OAAA,GAAU,OAAO,UAAA,EAAW;AAClC,IAAA,IAAI,CAAC,OAAA,EAAS;AACZ,MAAA,MAAM,IAAIA,+BAAA,CAAc,GAAA,EAAK,EAAE,OAAA,EAAS,4BAA4B,CAAA;AAAA,IACtE;AAEA,IAAA,MAAM,KAAA,GAAQ,MAAM,OAAA,CAAQ,UAAA,CAAW,OAAO,CAAA;AAE9C,IAAA,IAAI,CAAC,KAAA,EAAO;AACV,MAAA,MAAM,IAAIA,gCAAc,GAAA,EAAK,EAAE,SAAS,CAAA,eAAA,EAAkB,OAAO,eAAe,CAAA;AAAA,IAClF;AAEA,IAAA,OAAO,KAAA;AAAA,EACT,SAAS,KAAA,EAAO;AACd,IAAAC,6BAAA,CAAY,OAAO,wBAAwB,CAAA;AAAA,EAC7C;AACF;AAMA,eAAsB,2BAAA,CAA4B,EAAE,MAAA,EAAQ,IAAA,EAAK,EAAyB;AACxF,EAAA,IAAI;AACF,IAAA,MAAM,OAAA,GAAU,OAAO,UAAA,EAAW;AAClC,IAAA,IAAI,CAAC,OAAA,EAAS;AACZ,MAAA,MAAM,IAAID,+BAAA,CAAc,GAAA,EAAK,EAAE,OAAA,EAAS,4BAA4B,CAAA;AAAA,IACtE;AAEA,IAAA,IAAI,CAAC,IAAA,EAAM;AACT,MAAA,MAAM,IAAIA,+BAAA,CAAc,GAAA,EAAK,EAAE,OAAA,EAAS,4BAA4B,CAAA;AAAA,IACtE;AAEA,IAAA,MAAM,EAAE,OAAA,EAAS,UAAA,EAAW,GAAI,IAAA;AAEhC,IAAA,IAAI,UAAA,EAAY,IAAA,IAAQ,UAAA,CAAW,IAAA,GAAO,CAAA,EAAG;AAC3C,MAAA,MAAM,IAAIA,+BAAA,CAAc,GAAA,EAAK,EAAE,OAAA,EAAS,uCAAuC,CAAA;AAAA,IACjF;AAEA,IAAA,IAAI,UAAA,EAAY,OAAA,IAAW,UAAA,CAAW,OAAA,GAAU,CAAA,EAAG;AACjD,MAAA,MAAM,IAAIA,+BAAA,CAAc,GAAA,EAAK,EAAE,OAAA,EAAS,2CAA2C,CAAA;AAAA,IACrF;AAEA,IAAA,IAAI,YAAY,SAAA,EAAW;AACzB,MAAA,MAAM,EAAE,KAAA,EAAO,GAAA,EAAI,GAAI,UAAA,CAAW,SAAA;AAElC,MAAA,IAAI,KAAA,IAAS,EAAE,KAAA,YAAiB,IAAA,CAAA,EAAO;AACrC,QAAA,MAAM,IAAIA,+BAAA,CAAc,GAAA,EAAK,EAAE,OAAA,EAAS,qCAAqC,CAAA;AAAA,MAC/E;AAEA,MAAA,IAAI,GAAA,IAAO,EAAE,GAAA,YAAe,IAAA,CAAA,EAAO;AACjC,QAAA,MAAM,IAAIA,+BAAA,CAAc,GAAA,EAAK,EAAE,OAAA,EAAS,qCAAqC,CAAA;AAAA,MAC/E;AAAA,IACF;AAEA,IAAA,OAAO,QAAQ,oBAAA,CAAqB;AAAA,MAClC,UAAA;AAAA,MACA;AAAA,KACD,CAAA;AAAA,EACH,SAAS,KAAA,EAAO;AACd,IAAAC,6BAAA,CAAY,OAAO,mCAAmC,CAAA;AAAA,EACxD;AACF","file":"chunk-L265APUD.cjs","sourcesContent":["import type { AITracesPaginatedArg } from '@mastra/core';\nimport { HTTPException } from '../http-exception';\nimport type { Context } from '../types';\n\nimport { handleError } from './error';\n\ninterface ObservabilityContext extends Context {\n  traceId?: string;\n  body?: AITracesPaginatedArg;\n}\n\n/**\n * Get a complete AI trace by trace ID\n * Returns all spans in the trace with their parent-child relationships\n */\nexport async function getAITraceHandler({ mastra, traceId }: ObservabilityContext & { traceId: string }) {\n  try {\n    if (!traceId) {\n      throw new HTTPException(400, { message: 'Trace ID is required' });\n    }\n\n    const storage = mastra.getStorage();\n    if (!storage) {\n      throw new HTTPException(500, { message: 'Storage is not available' });\n    }\n\n    const trace = await storage.getAITrace(traceId);\n\n    if (!trace) {\n      throw new HTTPException(404, { message: `Trace with ID '${traceId}' not found` });\n    }\n\n    return trace;\n  } catch (error) {\n    handleError(error, 'Error getting AI trace');\n  }\n}\n\n/**\n * Get paginated AI traces with filtering and pagination\n * Returns only root spans (parent spans) for pagination, not child spans\n */\nexport async function getAITracesPaginatedHandler({ mastra, body }: ObservabilityContext) {\n  try {\n    const storage = mastra.getStorage();\n    if (!storage) {\n      throw new HTTPException(500, { message: 'Storage is not available' });\n    }\n\n    if (!body) {\n      throw new HTTPException(400, { message: 'Request body is required' });\n    }\n\n    const { filters, pagination } = body;\n\n    if (pagination?.page && pagination.page < 0) {\n      throw new HTTPException(400, { message: 'Page must be a non-negative integer' });\n    }\n\n    if (pagination?.perPage && pagination.perPage < 0) {\n      throw new HTTPException(400, { message: 'Per page must be a non-negative integer' });\n    }\n\n    if (pagination?.dateRange) {\n      const { start, end } = pagination.dateRange;\n\n      if (start && !(start instanceof Date)) {\n        throw new HTTPException(400, { message: 'Invalid date format in date range' });\n      }\n\n      if (end && !(end instanceof Date)) {\n        throw new HTTPException(400, { message: 'Invalid date format in date range' });\n      }\n    }\n\n    return storage.getAITracesPaginated({\n      pagination,\n      filters,\n    });\n  } catch (error) {\n    handleError(error, 'Error getting AI traces paginated');\n  }\n}\n"]}