import { getInputOptions } from './chunk-LN4WTW4C.js';
import { createWorkspacePackageMap, getPackageName, getPackageRootPath, bundleExternals, tsConfigPaths, aliasHono, extractMastraOption, removeAllOptionsFromMastraExcept } from './chunk-5ZHIZCMJ.js';
import { watch } from 'rollup';
import { findWorkspacesRoot } from 'find-workspaces';
import { extname, dirname } from 'path';
import resolveFrom from 'resolve-from';
import { builtinModules } from 'module';
import { noopLogger } from '@mastra/core/logger';

function isBuiltinModule(specifier) {
  return builtinModules.includes(specifier) || specifier.startsWith("node:") || builtinModules.includes(specifier.replace(/^node:/, ""));
}
function safeResolve(id, importer) {
  try {
    return resolveFrom(importer, id);
  } catch {
    return null;
  }
}
function nodeModulesExtensionResolver() {
  return {
    name: "node-modules-extension-resolver",
    resolveId(id, importer) {
      if (id.startsWith(".") || id.startsWith("/") || !importer) {
        return null;
      }
      if (isBuiltinModule(id)) {
        return null;
      }
      if (id.startsWith("@") && id.split("/").length === 2) {
        return null;
      }
      if (!id.startsWith("@") && id.split("/").length === 1) {
        return null;
      }
      const foundExt = extname(id);
      if (foundExt) {
        return null;
      }
      try {
        const resolved = import.meta.resolve(id);
        if (!extname(resolved)) {
          throw new Error(`Cannot resolve ${id} from ${importer}`);
        }
        return null;
      } catch (e) {
        const resolved = safeResolve(id, importer);
        if (resolved) {
          return {
            id: resolved,
            external: true
          };
        }
        for (const ext of [".mjs", ".js", ".cjs"]) {
          const resolved2 = safeResolve(id + ext, importer);
          if (resolved2) {
            const pkgName = getPackageName(id);
            if (!pkgName) {
              return null;
            }
            const pkgJsonPath = safeResolve(`${pkgName}/package.json`, importer);
            if (!pkgJsonPath) {
              return null;
            }
            const newImportWithExtension = resolved2.replace(dirname(pkgJsonPath), pkgName);
            return {
              id: newImportWithExtension,
              external: true
            };
          }
        }
      }
      return null;
    }
  };
}
async function getInputOptions2(entryFile, platform, env, { sourcemap = false, transpilePackages = [] } = {}) {
  const dependencies = /* @__PURE__ */ new Map();
  const workspaceMap = await createWorkspacePackageMap();
  const workspaceRoot = findWorkspacesRoot()?.location;
  const depsToOptimize = /* @__PURE__ */ new Map();
  if (transpilePackages.length) {
    for (const pkg of transpilePackages) {
      const isWorkspace = workspaceMap.has(pkg);
      const exports = ["*"];
      const pkgName = getPackageName(pkg);
      let rootPath = null;
      if (pkgName && pkgName !== "#tools") {
        rootPath = await getPackageRootPath(pkgName);
      }
      depsToOptimize.set(pkg, { exports, isWorkspace, rootPath });
    }
    const { output, reverseVirtualReferenceMap } = await bundleExternals(
      depsToOptimize,
      ".mastra/.build",
      noopLogger,
      {
        transpilePackages,
        isDev: true
      },
      { workspaceRoot, workspaceMap }
    );
    for (const file of output) {
      if (file.type === "asset") {
        continue;
      }
      if (file.isEntry && reverseVirtualReferenceMap.has(file.name)) {
        dependencies.set(reverseVirtualReferenceMap.get(file.name), file.fileName);
      }
    }
  }
  const inputOptions = await getInputOptions(
    entryFile,
    {
      dependencies,
      externalDependencies: /* @__PURE__ */ new Set(),
      invalidChunks: /* @__PURE__ */ new Set(),
      workspaceMap
    },
    platform,
    env,
    { sourcemap, isDev: true, workspaceRoot }
  );
  if (Array.isArray(inputOptions.plugins)) {
    const plugins = [];
    inputOptions.plugins.forEach((plugin) => {
      if (plugin?.name === "node-resolve") {
        return;
      }
      if (plugin?.name === "tsconfig-paths") {
        plugins.push(
          tsConfigPaths({
            localResolve: true
          })
        );
        return;
      }
      plugins.push(plugin);
    });
    inputOptions.plugins = plugins;
    inputOptions.plugins.push(aliasHono());
    inputOptions.plugins.push(nodeModulesExtensionResolver());
  }
  return inputOptions;
}
async function createWatcher(inputOptions, outputOptions) {
  const watcher = await watch({
    ...inputOptions,
    output: {
      ...outputOptions,
      format: "esm",
      entryFileNames: "[name].mjs",
      chunkFileNames: "[name].mjs"
    }
  });
  return watcher;
}

// src/build/babel/remove-all-options-server.ts
function removeAllOptionsExceptServer(result, logger) {
  return removeAllOptionsFromMastraExcept(result, "server", logger);
}

// src/build/serverOptions.ts
async function getServerOptions(entryFile, outputDir, logger) {
  const result = await extractMastraOption(
    "server",
    entryFile,
    removeAllOptionsExceptServer,
    outputDir,
    logger
  );
  if (!result) {
    return null;
  }
  return result.getConfig();
}

export { createWatcher, getInputOptions2 as getInputOptions, getServerOptions };
//# sourceMappingURL=chunk-4CAKOUIN.js.map
//# sourceMappingURL=chunk-4CAKOUIN.js.map