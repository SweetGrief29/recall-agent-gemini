'use strict';

var chunkHR2HOA5D_cjs = require('./chunk-HR2HOA5D.cjs');
var babel = require('@babel/core');
var commonjs2 = require('@rollup/plugin-commonjs');
var json2 = require('@rollup/plugin-json');
var nodeResolve = require('@rollup/plugin-node-resolve');
var virtual = require('@rollup/plugin-virtual');
var esmShim = require('@rollup/plugin-esm-shim');
var fs = require('fs');
var promises = require('fs/promises');
var url = require('url');
var rollup = require('rollup');
var originalEsbuild = require('rollup-plugin-esbuild');
var module$1 = require('module');
var path = require('path');
var child_process = require('child_process');
var typescriptPaths = require('typescript-paths');
var rollupPlugin = require('@optimize-lodash/rollup-plugin');
var localPkg = require('local-pkg');
var slugify = require('@sindresorhus/slugify');
var findWorkspaces = require('find-workspaces');
var fsExtra = require('fs-extra');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}

var babel__namespace = /*#__PURE__*/_interopNamespace(babel);
var commonjs2__default = /*#__PURE__*/_interopDefault(commonjs2);
var json2__default = /*#__PURE__*/_interopDefault(json2);
var nodeResolve__default = /*#__PURE__*/_interopDefault(nodeResolve);
var virtual__default = /*#__PURE__*/_interopDefault(virtual);
var esmShim__default = /*#__PURE__*/_interopDefault(esmShim);
var fs__default = /*#__PURE__*/_interopDefault(fs);
var originalEsbuild__default = /*#__PURE__*/_interopDefault(originalEsbuild);
var path__default = /*#__PURE__*/_interopDefault(path);
var slugify__default = /*#__PURE__*/_interopDefault(slugify);

function esbuild(options = {}) {
  return originalEsbuild__default.default({
    target: "node20",
    platform: "node",
    minify: false,
    ...options
  });
}
function isNodeBuiltin(dep) {
  const [pkg] = dep.split("/");
  return dep.startsWith("node:") || module$1.builtinModules.includes(dep) || module$1.builtinModules.includes(pkg);
}
function aliasHono() {
  return {
    name: "hono-alias",
    resolveId(id) {
      if (!id.startsWith("@hono/") && !id.startsWith("hono/") && id !== "hono" && id !== "hono-openapi") {
        return;
      }
      const path2 = undefined(id);
      return url.fileURLToPath(path2);
    }
  };
}
function removeDeployer() {
  const t = babel__namespace.default.types;
  return {
    name: "remove-deployer",
    visitor: {
      NewExpression(path2, state) {
        const varDeclaratorPath = path2.findParent((path3) => t.isVariableDeclarator(path3.node));
        if (!varDeclaratorPath) {
          return;
        }
        const parentNode = path2.parentPath.node;
        if (!t.isVariableDeclarator(parentNode) || !t.isIdentifier(parentNode.id) || parentNode.id.name !== "mastra") {
          return;
        }
        if (!state.hasReplaced) {
          state.hasReplaced = true;
          const newMastraObj = t.cloneNode(path2.node);
          if (t.isObjectExpression(newMastraObj.arguments[0]) && newMastraObj.arguments[0].properties?.[0]) {
            const deployer = newMastraObj.arguments[0].properties.find(
              (prop) => t.isObjectProperty(prop) && t.isIdentifier(prop.key) && prop.key.name === "deployer"
            );
            if (!deployer) {
              return;
            }
            newMastraObj.arguments[0].properties = newMastraObj.arguments[0].properties.filter(
              (prop) => prop !== deployer
            );
            if (t.isObjectProperty(deployer) && t.isIdentifier(deployer.value)) {
              const deployerBinding = state.file.scope.getBinding(deployer.value.name);
              if (deployerBinding) {
                deployerBinding?.path?.parentPath?.remove();
              }
            }
            path2.replaceWith(newMastraObj);
          }
        }
      }
    }
  };
}

// src/build/plugins/remove-deployer.ts
function removeDeployer2(mastraEntry, options) {
  return {
    name: "remove-deployer",
    transform(code, id) {
      if (id !== mastraEntry) {
        return;
      }
      return new Promise((resolve, reject) => {
        babel__namespace.transform(
          code,
          {
            babelrc: false,
            configFile: false,
            filename: id,
            plugins: [removeDeployer],
            sourceMaps: options?.sourcemap
          },
          (err, result) => {
            if (err) {
              return reject(err);
            }
            resolve({
              code: result.code,
              map: result.map
            });
          }
        );
      });
    }
  };
}
function spawn(command, args = [], options = {}) {
  return new Promise((resolve, reject) => {
    const childProcess = child_process.spawn(command, args, {
      // stdio: 'inherit',
      ...options
    });
    childProcess.on("error", (error) => {
      reject(error);
    });
    let stderr = "";
    childProcess.stderr?.on("data", (message) => {
      stderr += message;
    });
    childProcess.on("close", (code) => {
      if (code === 0) {
        resolve();
      } else {
        reject(new Error(stderr));
      }
    });
  });
}
function validate(file) {
  return spawn(
    "node",
    [
      "--import",
      undefined("@mastra/deployer/loader"),
      "--input-type=module",
      "-e",
      `import('file://${file.replaceAll("\\", "/")}')`
    ],
    {
      cwd: path.dirname(file)
    }
  );
}
var PLUGIN_NAME = "tsconfig-paths";
function tsConfigPaths({ tsConfigPath, respectCoreModule, localResolve } = {}) {
  let handler;
  return {
    name: PLUGIN_NAME,
    buildStart() {
      handler = typescriptPaths.createHandler({
        log: () => {
        },
        tsConfigPath,
        respectCoreModule,
        falllback: (moduleName) => fs__default.default.existsSync(moduleName)
      });
      return;
    },
    async resolveId(request, importer, options) {
      if (!importer || request.startsWith("\0")) {
        return null;
      }
      const moduleName = handler?.(request, path.normalize(importer));
      if (!moduleName) {
        let importerMeta = {};
        const resolved = await this.resolve(request, importer, { skipSelf: true, ...options });
        if (!resolved) {
          return null;
        }
        if (localResolve) {
          const importerInfo = this.getModuleInfo(importer);
          importerMeta = importerInfo?.meta || {};
          if (!request.startsWith("./") && !request.startsWith("../") && importerMeta?.[PLUGIN_NAME]?.resolved) {
            return {
              ...resolved,
              external: !request.startsWith("hono/") && request !== "hono"
            };
          }
        }
        return {
          ...resolved,
          meta: {
            ...resolved.meta || {},
            ...importerMeta
          }
        };
      }
      if (!path__default.default.extname(moduleName)) {
        const resolved = await this.resolve(moduleName, importer, { skipSelf: true, ...options });
        if (!resolved) {
          return null;
        }
        return {
          ...resolved,
          meta: {
            ...resolved.meta,
            [PLUGIN_NAME]: {
              resolved: true
            }
          }
        };
      }
      return {
        id: moduleName,
        meta: {
          [PLUGIN_NAME]: {
            resolved: true
          }
        }
      };
    }
  };
}
function removeAllOptionsFromMastraExcept(result, option, logger) {
  const t = babel__namespace.default.types;
  return {
    name: "remove-all-except-" + option + "-config",
    visitor: {
      ExportNamedDeclaration: {
        // remove all exports
        exit(path2) {
          path2.remove();
        }
      },
      NewExpression(path2, state) {
        const varDeclaratorPath = path2.findParent((path3) => t.isVariableDeclarator(path3.node));
        if (!varDeclaratorPath) {
          return;
        }
        const parentNode = path2.parentPath.node;
        if (!t.isVariableDeclarator(parentNode) || !t.isIdentifier(parentNode.id) || parentNode.id.name !== "mastra") {
          return;
        }
        let mastraArgs = t.objectExpression([]);
        if (t.isObjectExpression(path2.node.arguments[0])) {
          mastraArgs = path2.node.arguments[0];
        }
        let telemetry = mastraArgs.properties.find(
          // @ts-ignore
          (prop) => prop.key.name === option
        );
        let telemetryValue = t.objectExpression([]);
        const programPath = path2.scope.getProgramParent().path;
        if (!programPath) {
          return;
        }
        if (telemetry && t.isObjectProperty(telemetry) && t.isExpression(telemetry.value)) {
          result.hasCustomConfig = true;
          telemetryValue = telemetry.value;
          if (t.isIdentifier(telemetry.value) && telemetry.value.name === option) {
            const telemetryBinding = state.file.scope.getBinding(option);
            if (telemetryBinding && t.isVariableDeclarator(telemetryBinding.path.node)) {
              const id = path2.scope.generateUidIdentifier(option);
              telemetryBinding.path.replaceWith(t.variableDeclarator(id, telemetryBinding.path.node.init));
              telemetryValue = id;
            }
          }
        }
        const exportDeclaration = t.exportNamedDeclaration(
          t.variableDeclaration("const", [t.variableDeclarator(t.identifier(option), telemetryValue)]),
          []
        );
        programPath.node.body.push(exportDeclaration);
      },
      Program: {
        exit(path2) {
          const hasExport = path2.node.body.some(
            (node) => node.type === "ExportNamedDeclaration" || node.type === "ExportDefaultDeclaration"
          );
          if (!hasExport) {
            if (logger) {
              logger.warn(`Mastra ${option} config could not be extracted. Please make sure your entry file looks like this:
export const mastra = new Mastra({
  ${option}: <value>
})

`);
            }
            const fallbackExportDeclaration = t.exportNamedDeclaration(
              t.variableDeclaration("const", [t.variableDeclarator(t.identifier(option), t.objectExpression([]))]),
              []
            );
            path2.node.body.push(fallbackExportDeclaration);
          }
        }
      }
    }
  };
}

// src/build/babel/remove-all-options-bundler.ts
function removeAllOptionsExceptBundler(result, logger) {
  return removeAllOptionsFromMastraExcept(result, "bundler", logger);
}
function removeNonReferencedNodes() {
  const t = babel__namespace.default.types;
  return {
    name: "remove-non-referenced-nodes",
    visitor: {
      Program(path2) {
        const scope = path2.scope;
        const currentBody = path2.get("body");
        const filteredBody = currentBody.filter((childPath) => {
          if (childPath.isExportDeclaration()) {
            return true;
          }
          if (childPath.isVariableDeclaration()) {
            return childPath.node.declarations.some((decl) => {
              if (!t.isIdentifier(decl.id)) {
                return false;
              }
              const name = decl.id.name;
              const binding = scope.getBinding(name);
              return binding && (binding.referenced || binding.referencePaths.length > 0);
            });
          }
          if (childPath.isFunctionDeclaration() || childPath.isClassDeclaration()) {
            if (!t.isIdentifier(childPath.node.id)) {
              return false;
            }
            const name = childPath.node.id.name;
            const binding = scope.getBinding(name);
            return binding && (binding.referenced || binding.referencePaths.length > 0);
          }
          if (childPath.isImportDeclaration()) {
            return childPath.node.specifiers.some((specifier) => {
              const importedName = specifier.local.name;
              const binding = scope.getBinding(importedName);
              return binding && (binding.referenced || binding.referencePaths.length > 0);
            });
          }
          return false;
        });
        path2.set(
          "body",
          filteredBody.map((p) => p.node)
        );
      }
    }
  };
}

// src/build/plugins/remove-unused-references.ts
function recursiveRemoveNonReferencedNodes(code) {
  return new Promise(async (resolve, reject) => {
    babel__namespace.transform(
      code,
      {
        babelrc: false,
        configFile: false,
        plugins: [removeNonReferencedNodes()]
      },
      (err, result) => {
        if (err) {
          return reject(err);
        }
        if (result && result.code !== code) {
          return recursiveRemoveNonReferencedNodes(result.code).then(resolve, reject);
        }
        resolve({
          code: result.code,
          map: result.map
        });
      }
    );
  });
}
function extractMastraOptionBundler(name, entryFile, transformer, result, logger) {
  return rollup.rollup({
    logLevel: "silent",
    input: {
      [`${name}-config`]: entryFile
    },
    treeshake: "smallest",
    plugins: [
      tsConfigPaths(),
      // transpile typescript to something we understand
      esbuild(),
      rollupPlugin.optimizeLodashImports(),
      commonjs2__default.default({
        extensions: [".js", ".ts"],
        strictRequires: "strict",
        transformMixedEsModules: true,
        ignoreTryCatch: false
      }),
      json2__default.default(),
      {
        name: `extract-${name}-config`,
        transform(code, id) {
          if (id !== entryFile) {
            return;
          }
          return new Promise((resolve, reject) => {
            babel__namespace.transform(
              code,
              {
                babelrc: false,
                configFile: false,
                filename: id,
                plugins: [transformer(result, logger)]
              },
              (err, result2) => {
                if (err) {
                  return reject(err);
                }
                resolve({
                  code: result2.code,
                  map: result2.map
                });
              }
            );
          });
        }
      },
      // let esbuild remove all unused imports
      esbuild(),
      {
        name: "cleanup",
        transform(code, id) {
          if (id !== entryFile) {
            return;
          }
          return recursiveRemoveNonReferencedNodes(code);
        }
      },
      // let esbuild remove it once more
      esbuild()
    ]
  });
}
async function extractMastraOption(name, entryFile, transformer, outputDir, logger) {
  const result = {
    hasCustomConfig: false
  };
  const bundler = await extractMastraOptionBundler(name, entryFile, transformer, result, logger);
  const output = await bundler.write({
    dir: outputDir,
    format: "es",
    entryFileNames: "[name].mjs"
  });
  if (result.hasCustomConfig) {
    const configPath = `${outputDir}/${name}-config.mjs`;
    return {
      bundleOutput: output,
      getConfig: () => import(`file:${configPath}`).then((m) => m[name])
    };
  }
  return null;
}

// src/build/bundlerOptions.ts
async function getBundlerOptions(entryFile, outputDir, logger) {
  const result = await extractMastraOption(
    "bundler",
    entryFile,
    removeAllOptionsExceptBundler,
    outputDir,
    logger
  );
  if (!result) {
    return null;
  }
  return result.getConfig();
}
function checkConfigExport(result) {
  const t = babel__namespace.default.types;
  const mastraVars = /* @__PURE__ */ new Set();
  return {
    visitor: {
      ExportNamedDeclaration(path2) {
        const decl = path2.node.declaration;
        if (t.isVariableDeclaration(decl)) {
          const varDecl = decl.declarations[0];
          if (t.isIdentifier(varDecl?.id, { name: "mastra" }) && t.isNewExpression(varDecl.init) && t.isIdentifier(varDecl.init.callee, { name: "Mastra" })) {
            result.hasValidConfig = true;
          }
        }
        if (Array.isArray(path2.node.specifiers)) {
          for (const spec of path2.node.specifiers) {
            if (t.isExportSpecifier(spec) && t.isIdentifier(spec.exported, { name: "mastra" }) && t.isIdentifier(spec.local) && mastraVars.has(spec.local.name)) {
              result.hasValidConfig = true;
            }
          }
        }
      },
      // For cases 2-4 we need to track whether those variables are assigned to `new Mastra()`
      VariableDeclaration(path2) {
        for (const decl of path2.node.declarations) {
          if (t.isIdentifier(decl.id) && t.isNewExpression(decl.init) && t.isIdentifier(decl.init.callee, { name: "Mastra" })) {
            mastraVars.add(decl.id.name);
          }
        }
      }
    }
  };
}
function getPackageName(id) {
  const parts = id.split("/");
  if (id.startsWith("@")) {
    return parts.slice(0, 2).join("/");
  }
  return parts[0];
}
async function getPackageRootPath(packageName) {
  let rootPath;
  try {
    const pkg = await localPkg.getPackageInfo(packageName);
    rootPath = pkg?.rootPath ?? null;
  } catch (e) {
    rootPath = null;
  }
  return rootPath;
}
function getCompiledDepCachePath(rootPath, packageName) {
  return path.join(rootPath, "node_modules", ".cache", packageName);
}
var createWorkspacePackageMap = async () => {
  const workspaces = await findWorkspaces.findWorkspaces();
  const workspaceMap = new Map(
    workspaces?.map((workspace) => [
      workspace.package.name,
      {
        location: workspace.location,
        dependencies: workspace.package.dependencies,
        version: workspace.package.version
      }
    ]) ?? []
  );
  return workspaceMap;
};
var collectTransitiveWorkspaceDependencies = ({
  workspaceMap,
  initialDependencies,
  logger
}) => {
  const usedWorkspacePackages = /* @__PURE__ */ new Set();
  const queue = Array.from(initialDependencies);
  const resolutions = {};
  while (queue.length > 0) {
    const len = queue.length;
    for (let i = 0; i < len; i += 1) {
      const pkgName = queue.shift();
      if (!pkgName || usedWorkspacePackages.has(pkgName)) {
        continue;
      }
      const dep = workspaceMap.get(pkgName);
      if (!dep) continue;
      const root = findWorkspaces.findWorkspacesRoot();
      if (!root) {
        throw new Error("Could not find workspace root");
      }
      const depsService = new chunkHR2HOA5D_cjs.DepsService(root.location);
      depsService.__setLogger(logger);
      const sanitizedName = slugify__default.default(pkgName);
      const tgzPath = depsService.getWorkspaceDependencyPath({
        pkgName: sanitizedName,
        version: dep.version
      });
      resolutions[pkgName] = tgzPath;
      usedWorkspacePackages.add(pkgName);
      for (const [depName, _depVersion] of Object.entries(dep?.dependencies ?? {})) {
        if (!usedWorkspacePackages.has(depName) && workspaceMap.has(depName)) {
          queue.push(depName);
        }
      }
    }
  }
  return { resolutions, usedWorkspacePackages };
};
var packWorkspaceDependencies = async ({
  workspaceMap,
  usedWorkspacePackages,
  bundleOutputDir,
  logger
}) => {
  const root = findWorkspaces.findWorkspacesRoot();
  if (!root) {
    throw new Error("Could not find workspace root");
  }
  const depsService = new chunkHR2HOA5D_cjs.DepsService(root.location);
  depsService.__setLogger(logger);
  if (usedWorkspacePackages.size > 0) {
    const workspaceDirPath = path.join(bundleOutputDir, "workspace-module");
    await fsExtra.ensureDir(workspaceDirPath);
    logger.info(`Packaging ${usedWorkspacePackages.size} workspace dependencies...`);
    const batchSize = 5;
    const packages = Array.from(usedWorkspacePackages.values());
    for (let i = 0; i < packages.length; i += batchSize) {
      const batch = packages.slice(i, i + batchSize);
      logger.info(
        `Packaging batch ${Math.floor(i / batchSize) + 1}/${Math.ceil(packages.length / batchSize)}: ${batch.join(", ")}`
      );
      await Promise.all(
        batch.map(async (pkgName) => {
          const dep = workspaceMap.get(pkgName);
          const sanitizedName = slugify__default.default(pkgName);
          if (!dep) return;
          await depsService.pack({ dir: dep.location, destination: workspaceDirPath, sanitizedName });
        })
      );
    }
    logger.info(`Successfully packaged ${usedWorkspacePackages.size} workspace dependencies`);
  }
};

// src/build/analyze.ts
var globalExternals = [
  "pino",
  "pino-pretty",
  "@libsql/client",
  "pg",
  "libsql",
  "jsdom",
  "sqlite3",
  "fastembed",
  "nodemailer",
  "#tools"
];
function findExternalImporter(module, external, allOutputs) {
  const capturedFiles = /* @__PURE__ */ new Set();
  for (const id of module.imports) {
    if (id === external) {
      return module;
    } else {
      if (id.endsWith(".mjs")) {
        capturedFiles.add(id);
      }
    }
  }
  for (const file of capturedFiles) {
    const nextModule = allOutputs.find((o) => o.fileName === file);
    if (nextModule) {
      const importer = findExternalImporter(nextModule, external, allOutputs);
      if (importer) {
        return importer;
      }
    }
  }
  return null;
}
async function analyze(entry, mastraEntry, isVirtualFile, platform, logger, sourcemapEnabled = false, workspaceMap) {
  logger.info("Analyzing dependencies...");
  let virtualPlugin = null;
  if (isVirtualFile) {
    virtualPlugin = virtual__default.default({
      "#entry": entry
    });
    entry = "#entry";
  }
  const normalizedMastraEntry = mastraEntry.replaceAll("\\", "/");
  const optimizerBundler = await rollup.rollup({
    logLevel: process.env.MASTRA_BUNDLER_DEBUG === "true" ? "debug" : "silent",
    input: isVirtualFile ? "#entry" : entry,
    treeshake: "smallest",
    preserveSymlinks: true,
    plugins: [
      virtualPlugin,
      tsConfigPaths(),
      {
        name: "custom-alias-resolver",
        resolveId(id) {
          if (id === "#server") {
            return url.fileURLToPath(undefined("@mastra/deployer/server")).replaceAll("\\", "/");
          }
          if (id === "#mastra") {
            return normalizedMastraEntry;
          }
          if (id.startsWith("@mastra/server")) {
            return url.fileURLToPath(undefined(id));
          }
          if (id === "#tools") {
            return {
              id: "#tools",
              external: true
            };
          }
        }
      },
      json2__default.default(),
      esbuild(),
      commonjs2__default.default({
        strictRequires: "debug",
        ignoreTryCatch: false,
        transformMixedEsModules: true,
        extensions: [".js", ".ts"]
      }),
      removeDeployer2(normalizedMastraEntry, { sourcemap: sourcemapEnabled }),
      esbuild()
    ].filter(Boolean)
  });
  const { output } = await optimizerBundler.generate({
    format: "esm",
    inlineDynamicImports: true
  });
  await optimizerBundler.close();
  const depsToOptimize = /* @__PURE__ */ new Map();
  for (const [dep, bindings] of Object.entries(output[0].importedBindings)) {
    if (isNodeBuiltin(dep)) {
      continue;
    }
    const isWorkspace = workspaceMap.has(dep);
    const pkgName = getPackageName(dep);
    let rootPath = null;
    if (pkgName && pkgName !== "#tools") {
      rootPath = await getPackageRootPath(pkgName);
    }
    depsToOptimize.set(dep, { exports: bindings, rootPath, isWorkspace });
  }
  for (const o of output) {
    if (o.type !== "chunk") {
      continue;
    }
    const dynamicImports = o.dynamicImports.filter((d) => d !== "#tools");
    if (!dynamicImports.length) {
      continue;
    }
    for (const dynamicImport of dynamicImports) {
      if (!depsToOptimize.has(dynamicImport) && !isNodeBuiltin(dynamicImport)) {
        depsToOptimize.set(dynamicImport, { exports: ["*"], rootPath: null, isWorkspace: false });
      }
    }
  }
  return depsToOptimize;
}
async function bundleExternals(depsToOptimize, outputDir, logger, bundlerOptions, meta) {
  logger.info("Optimizing dependencies...");
  logger.debug(
    `${Array.from(depsToOptimize.keys()).map((key) => `- ${key}`).join("\n")}`
  );
  const { externals: customExternals = [], transpilePackages = [], isDev = false } = bundlerOptions || {};
  const { workspaceRoot = null, workspaceMap = /* @__PURE__ */ new Map() } = meta || {};
  const allExternals = [...globalExternals, ...customExternals];
  const reverseVirtualReferenceMap = /* @__PURE__ */ new Map();
  const virtualDependencies = /* @__PURE__ */ new Map();
  for (const [dep, { exports, isWorkspace, rootPath }] of depsToOptimize.entries()) {
    let name = dep.replaceAll("/", "-");
    if (isWorkspace && rootPath && isDev && workspaceRoot) {
      const absolutePath = getCompiledDepCachePath(rootPath, name);
      name = absolutePath.replace(workspaceRoot, "").replace(/^[/\\]+/, "");
    }
    reverseVirtualReferenceMap.set(name, dep);
    const virtualFile = [];
    let exportStringBuilder = [];
    for (const local of exports) {
      if (local === "*") {
        virtualFile.push(`export * from '${dep}';`);
      } else if (local === "default") {
        virtualFile.push(`export { default } from '${dep}';`);
      } else {
        exportStringBuilder.push(local);
      }
    }
    if (exportStringBuilder.length > 0) {
      virtualFile.push(`export { ${exportStringBuilder.join(", ")} } from '${dep}';`);
    }
    virtualDependencies.set(dep, {
      name,
      virtual: virtualFile.join("\n")
    });
  }
  const transpilePackagesMap = /* @__PURE__ */ new Map();
  for (const pkg of transpilePackages) {
    const dir = await getPackageRootPath(pkg);
    if (dir) {
      transpilePackagesMap.set(pkg, dir);
    }
  }
  const bundler = await rollup.rollup({
    logLevel: process.env.MASTRA_BUNDLER_DEBUG === "true" ? "debug" : "silent",
    input: Array.from(virtualDependencies.entries()).reduce(
      (acc, [dep, virtualDep]) => {
        acc[virtualDep.name] = `#virtual-${dep}`;
        return acc;
      },
      {}
    ),
    external: allExternals,
    treeshake: "smallest",
    plugins: [
      virtual__default.default(
        Array.from(virtualDependencies.entries()).reduce(
          (acc, [dep, virtualDep]) => {
            acc[`#virtual-${dep}`] = virtualDep.virtual;
            return acc;
          },
          {}
        )
      ),
      transpilePackagesMap.size ? esbuild({
        format: "esm",
        include: [...transpilePackagesMap.values()].map((p) => {
          return new RegExp(`^${p.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")}/(?!.*node_modules).*$`);
        })
      }) : null,
      commonjs2__default.default({
        strictRequires: "strict",
        transformMixedEsModules: true,
        ignoreTryCatch: false
      }),
      isDev ? esmShim__default.default() : void 0,
      nodeResolve__default.default({
        preferBuiltins: true,
        exportConditions: ["node"],
        // Do not embed external dependencies into files that we write to `node_modules/.cache` (for the mastra dev + workspace use case)
        ...workspaceMap.size > 0 && isDev ? { resolveOnly: Array.from(workspaceMap.keys()) } : {}
      }),
      // hono is imported from deployer, so we need to resolve from here instead of the project root
      aliasHono(),
      json2__default.default()
    ].filter(Boolean)
  });
  const { output } = await bundler.write({
    format: "esm",
    /**
     * If Mastra is used inside a monorepo, we need to find the workspace root so that Rollup can use it as base for the output dir. This should only happen during `mastra dev`.
     *
     * Otherwise, use outputDir as normal.
     */
    dir: isDev ? workspaceRoot ? workspaceRoot : outputDir : outputDir,
    entryFileNames: "[name].mjs",
    chunkFileNames: "[name].mjs",
    hoistTransitiveImports: false
  });
  const moduleResolveMap = {};
  const filteredChunks = output.filter((o) => o.type === "chunk");
  for (const o of filteredChunks.filter((o2) => o2.isEntry || o2.isDynamicEntry)) {
    for (const external of allExternals) {
      if (external === "#tools") {
        continue;
      }
      const importer = findExternalImporter(o, external, filteredChunks);
      if (importer) {
        const fullPath = path.join(outputDir, importer.fileName);
        moduleResolveMap[fullPath] = moduleResolveMap[fullPath] || {};
        if (importer.moduleIds.length) {
          moduleResolveMap[fullPath][external] = importer.moduleIds[importer.moduleIds.length - 1]?.startsWith(
            "\0virtual:#virtual"
          ) ? importer.moduleIds[importer.moduleIds.length - 2] : importer.moduleIds[importer.moduleIds.length - 1];
        }
      }
    }
  }
  await promises.writeFile(path.join(outputDir, "module-resolve-map.json"), JSON.stringify(moduleResolveMap, null, 2));
  await bundler.close();
  return { output, reverseVirtualReferenceMap, usedExternals: moduleResolveMap };
}
async function validateOutput({
  output,
  reverseVirtualReferenceMap,
  usedExternals,
  outputDir,
  workspaceMap
}, logger) {
  const result = {
    invalidChunks: /* @__PURE__ */ new Set(),
    dependencies: /* @__PURE__ */ new Map(),
    externalDependencies: /* @__PURE__ */ new Set(),
    workspaceMap
  };
  for (const deps of Object.values(usedExternals)) {
    for (const dep of Object.keys(deps)) {
      result.externalDependencies.add(dep);
    }
  }
  for (const file of output) {
    if (file.type === "asset") {
      continue;
    }
    try {
      logger.debug(`Validating if ${file.fileName} is a valid module.`);
      if (file.isEntry && reverseVirtualReferenceMap.has(file.name)) {
        result.dependencies.set(reverseVirtualReferenceMap.get(file.name), file.fileName);
      }
      if (!file.isDynamicEntry && file.isEntry) {
        await validate(path.join(outputDir, file.fileName));
      }
    } catch (err) {
      result.invalidChunks.add(file.fileName);
      if (file.isEntry && reverseVirtualReferenceMap.has(file.name)) {
        const reference = reverseVirtualReferenceMap.get(file.name);
        const dep = reference.startsWith("@") ? reference.split("/").slice(0, 2).join("/") : reference.split("/")[0];
        result.externalDependencies.add(dep);
      }
    }
  }
  return result;
}
async function analyzeBundle(entries, mastraEntry, outputDir, platform, logger, sourcemapEnabled = false) {
  const mastraConfig = await promises.readFile(mastraEntry, "utf-8");
  const mastraConfigResult = {
    hasValidConfig: false
  };
  await babel__namespace.transformAsync(mastraConfig, {
    filename: mastraEntry,
    presets: [undefined("@babel/preset-typescript")],
    plugins: [checkConfigExport(mastraConfigResult)]
  });
  if (!mastraConfigResult.hasValidConfig) {
    logger.warn(`Invalid Mastra config. Please make sure that your entry file looks like this:
export const mastra = new Mastra({
  // your options
})
  
If you think your configuration is valid, please open an issue.`);
  }
  const workspaceMap = await createWorkspacePackageMap();
  const depsToOptimize = /* @__PURE__ */ new Map();
  for (const entry of entries) {
    const isVirtualFile = entry.includes("\n") || !fs.existsSync(entry);
    const analyzeResult = await analyze(
      entry,
      mastraEntry,
      isVirtualFile,
      platform,
      logger,
      sourcemapEnabled,
      workspaceMap
    );
    for (const [dep, { exports }] of analyzeResult.entries()) {
      if (depsToOptimize.has(dep)) {
        const existingEntry = depsToOptimize.get(dep);
        depsToOptimize.set(dep, {
          ...existingEntry,
          exports: [.../* @__PURE__ */ new Set([...existingEntry.exports, ...exports])]
        });
      } else {
        const isWorkspace = workspaceMap.has(dep);
        const pkgName = getPackageName(dep);
        let rootPath = null;
        if (pkgName && pkgName !== "#tools") {
          rootPath = await getPackageRootPath(pkgName);
        }
        depsToOptimize.set(dep, { exports, rootPath, isWorkspace });
      }
    }
  }
  const bundlerOptions = await getBundlerOptions(mastraEntry, outputDir);
  const { output, reverseVirtualReferenceMap, usedExternals } = await bundleExternals(
    depsToOptimize,
    outputDir,
    logger,
    bundlerOptions ?? void 0
  );
  const result = await validateOutput(
    { output, reverseVirtualReferenceMap, usedExternals, outputDir, workspaceMap },
    logger
  );
  return result;
}

exports.aliasHono = aliasHono;
exports.analyzeBundle = analyzeBundle;
exports.bundleExternals = bundleExternals;
exports.collectTransitiveWorkspaceDependencies = collectTransitiveWorkspaceDependencies;
exports.createWorkspacePackageMap = createWorkspacePackageMap;
exports.esbuild = esbuild;
exports.extractMastraOption = extractMastraOption;
exports.getBundlerOptions = getBundlerOptions;
exports.getPackageName = getPackageName;
exports.getPackageRootPath = getPackageRootPath;
exports.packWorkspaceDependencies = packWorkspaceDependencies;
exports.removeAllOptionsFromMastraExcept = removeAllOptionsFromMastraExcept;
exports.removeDeployer = removeDeployer2;
exports.tsConfigPaths = tsConfigPaths;
//# sourceMappingURL=chunk-T4L3WY7M.cjs.map
//# sourceMappingURL=chunk-T4L3WY7M.cjs.map