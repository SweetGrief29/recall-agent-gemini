{"version":3,"sources":["../src/build/plugins/esbuild.ts","../src/build/isNodeBuiltin.ts","../src/build/plugins/hono-alias.ts","../src/build/babel/remove-deployer.ts","../src/build/plugins/remove-deployer.ts","../src/validator/validate.ts","../src/build/plugins/tsconfig-paths.ts","../src/build/babel/remove-all-options-except.ts","../src/build/babel/remove-all-options-bundler.ts","../src/build/babel/remove-non-referenced-nodes.ts","../src/build/plugins/remove-unused-references.ts","../src/build/shared/extract-mastra-option.ts","../src/build/bundlerOptions.ts","../src/build/babel/check-config-export.ts","../src/build/utils.ts","../src/bundler/workspaceDependencies.ts","../src/build/analyze.ts"],"names":["originalEsbuild","builtinModules","path","fileURLToPath","babel","removeDeployer","babel2","nodeSpawn","dirname","createHandler","fs","normalize","babel5","rollup","optimizeLodashImports","commonjs","json","babel6","result","getPackageInfo","join","findWorkspaces","findWorkspacesRoot","DepsService","slugify","ensureDir","virtual","esmShim","nodeResolve","o","writeFile","readFile","babel8","existsSync"],"mappings":"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","file":"chunk-T4L3WY7M.cjs","sourcesContent":["import originalEsbuild from 'rollup-plugin-esbuild';\n\nexport function esbuild(options: Parameters<typeof originalEsbuild>[0] = {}) {\n  return originalEsbuild({\n    target: 'node20',\n    platform: 'node',\n    minify: false,\n    ...options,\n  });\n}\n","import { builtinModules } from 'node:module';\n\nexport function isNodeBuiltin(dep: string): boolean {\n  const [pkg] = dep.split('/');\n\n  return dep.startsWith('node:') || builtinModules.includes(dep) || builtinModules.includes(pkg!);\n}\n","import { fileURLToPath } from 'node:url';\nimport type { Plugin } from 'rollup';\n\n// hono is imported from deployer, so we need to resolve from here instead of the project root\nexport function aliasHono(): Plugin {\n  return {\n    name: 'hono-alias',\n    resolveId(id: string) {\n      if (!id.startsWith('@hono/') && !id.startsWith('hono/') && id !== 'hono' && id !== 'hono-openapi') {\n        return;\n      }\n\n      const path = import.meta.resolve(id);\n      return fileURLToPath(path);\n    },\n  } satisfies Plugin;\n}\n","import babel from '@babel/core';\n\nexport function removeDeployer() {\n  const t = babel.types;\n\n  return {\n    name: 'remove-deployer',\n    visitor: {\n      NewExpression(path, state) {\n        // is a variable declaration\n        const varDeclaratorPath = path.findParent(path => t.isVariableDeclarator(path.node));\n        if (!varDeclaratorPath) {\n          return;\n        }\n\n        const parentNode = path.parentPath.node;\n        // check if it's a const of mastra\n        if (!t.isVariableDeclarator(parentNode) || !t.isIdentifier(parentNode.id) || parentNode.id.name !== 'mastra') {\n          return;\n        }\n\n        if (!state.hasReplaced) {\n          state.hasReplaced = true;\n          const newMastraObj = t.cloneNode(path.node);\n          if (t.isObjectExpression(newMastraObj.arguments[0]) && newMastraObj.arguments[0].properties?.[0]) {\n            const deployer = newMastraObj.arguments[0].properties.find(\n              prop => t.isObjectProperty(prop) && t.isIdentifier(prop.key) && prop.key.name === 'deployer',\n            );\n\n            if (!deployer) {\n              return;\n            }\n\n            newMastraObj.arguments[0].properties = newMastraObj.arguments[0].properties.filter(\n              prop => prop !== deployer,\n            );\n\n            // try to find the binding of the deployer which should be the reference to the deployer\n            if (t.isObjectProperty(deployer) && t.isIdentifier(deployer.value)) {\n              const deployerBinding = state.file.scope.getBinding(deployer.value.name);\n\n              if (deployerBinding) {\n                deployerBinding?.path?.parentPath?.remove();\n              }\n            }\n\n            path.replaceWith(newMastraObj);\n          }\n        }\n      },\n    },\n  } as babel.PluginObj;\n}\n","import * as babel from '@babel/core';\nimport type { Plugin } from 'rollup';\n\nimport { removeDeployer as removeDeployerBabelPlugin } from '../babel/remove-deployer';\n\nexport function removeDeployer(mastraEntry: string, options?: { sourcemap?: boolean }): Plugin {\n  return {\n    name: 'remove-deployer',\n    transform(code, id) {\n      if (id !== mastraEntry) {\n        return;\n      }\n\n      return new Promise((resolve, reject) => {\n        babel.transform(\n          code,\n          {\n            babelrc: false,\n            configFile: false,\n            filename: id,\n            plugins: [removeDeployerBabelPlugin],\n            sourceMaps: options?.sourcemap,\n          },\n          (err, result) => {\n            if (err) {\n              return reject(err);\n            }\n\n            resolve({\n              code: result!.code!,\n              map: result!.map!,\n            });\n          },\n        );\n      });\n    },\n  } satisfies Plugin;\n}\n","import { spawn as nodeSpawn } from 'node:child_process';\nimport type { SpawnOptions } from 'node:child_process';\nimport { dirname } from 'node:path';\n\n/**\n * Promisified version of Node.js spawn function\n *\n * @param command - The command to run\n * @param args - List of string arguments\n * @param options - Spawn options\n * @returns Promise that resolves with the exit code when the process completes\n */\nfunction spawn(command: string, args: string[] = [], options: SpawnOptions = {}): Promise<void> {\n  return new Promise((resolve, reject) => {\n    const childProcess = nodeSpawn(command, args, {\n      // stdio: 'inherit',\n      ...options,\n    });\n\n    childProcess.on('error', error => {\n      reject(error);\n    });\n\n    let stderr = '';\n    childProcess.stderr?.on('data', message => {\n      stderr += message;\n    });\n\n    childProcess.on('close', code => {\n      if (code === 0) {\n        resolve();\n      } else {\n        reject(new Error(stderr));\n      }\n    });\n  });\n}\n\nexport function validate(file: string) {\n  return spawn(\n    'node',\n    [\n      '--import',\n      import.meta.resolve('@mastra/deployer/loader'),\n      '--input-type=module',\n      '-e',\n      `import('file://${file.replaceAll('\\\\', '/')}')`,\n    ],\n    {\n      cwd: dirname(file),\n    },\n  );\n}\n","import fs from 'node:fs';\nimport path, { normalize } from 'node:path';\nimport resolveFrom from 'resolve-from';\nimport type { Plugin } from 'rollup';\nimport type { RegisterOptions } from 'typescript-paths';\nimport { createHandler } from 'typescript-paths';\n\nconst PLUGIN_NAME = 'tsconfig-paths';\n\nexport type PluginOptions = Omit<RegisterOptions, 'loggerID'> & { localResolve?: boolean };\n\nexport function tsConfigPaths({ tsConfigPath, respectCoreModule, localResolve }: PluginOptions = {}): Plugin {\n  let handler: ReturnType<typeof createHandler>;\n  return {\n    name: PLUGIN_NAME,\n    buildStart() {\n      handler = createHandler({\n        log: () => {},\n        tsConfigPath,\n        respectCoreModule,\n        falllback: moduleName => fs.existsSync(moduleName),\n      });\n      return;\n    },\n    async resolveId(request, importer, options) {\n      if (!importer || request.startsWith('\\0')) {\n        return null;\n      }\n\n      const moduleName = handler?.(request, normalize(importer));\n      // No tsconfig alias found, so we need to resolve it normally\n      if (!moduleName) {\n        let importerMeta: { [PLUGIN_NAME]?: { resolved?: boolean } } = {};\n\n        const resolved = await this.resolve(request, importer, { skipSelf: true, ...options });\n        if (!resolved) {\n          return null;\n        }\n\n        // If localResolve is true, we need to check if the importer has been resolved by the tsconfig-paths plugin\n        // if so, we need to resolve the request from the importer instead of the root and mark it as external\n        if (localResolve) {\n          const importerInfo = this.getModuleInfo(importer);\n          importerMeta = importerInfo?.meta || {};\n\n          if (!request.startsWith('./') && !request.startsWith('../') && importerMeta?.[PLUGIN_NAME]?.resolved) {\n            return {\n              ...resolved,\n              external: !request.startsWith('hono/') && request !== 'hono',\n            };\n          }\n        }\n\n        return {\n          ...resolved,\n          meta: {\n            ...(resolved.meta || {}),\n            ...importerMeta,\n          },\n        };\n      }\n\n      // When a module does not have an extension, we need to resolve it to a file\n      if (!path.extname(moduleName)) {\n        const resolved = await this.resolve(moduleName, importer, { skipSelf: true, ...options });\n\n        if (!resolved) {\n          return null;\n        }\n\n        return {\n          ...resolved,\n          meta: {\n            ...resolved.meta,\n            [PLUGIN_NAME]: {\n              resolved: true,\n            },\n          },\n        };\n      }\n\n      return {\n        id: moduleName,\n        meta: {\n          [PLUGIN_NAME]: {\n            resolved: true,\n          },\n        },\n      };\n    },\n  } satisfies Plugin;\n}\n","import babel from '@babel/core';\nimport type { NodePath, types } from '@babel/core';\nimport type { Config as MastraConfig } from '@mastra/core/mastra';\nimport type { IMastraLogger } from '@mastra/core/logger';\n\nexport function removeAllOptionsFromMastraExcept(\n  result: { hasCustomConfig: boolean },\n  option: keyof MastraConfig,\n  logger?: IMastraLogger,\n) {\n  const t = babel.types;\n\n  return {\n    name: 'remove-all-except-' + option + '-config',\n    visitor: {\n      ExportNamedDeclaration: {\n        // remove all exports\n        exit(path) {\n          path.remove();\n        },\n      },\n\n      NewExpression(path, state) {\n        // is a variable declaration\n        const varDeclaratorPath = path.findParent(path => t.isVariableDeclarator(path.node));\n        if (!varDeclaratorPath) {\n          return;\n        }\n\n        const parentNode = path.parentPath.node;\n        // check if it's a const of mastra\n        if (!t.isVariableDeclarator(parentNode) || !t.isIdentifier(parentNode.id) || parentNode.id.name !== 'mastra') {\n          return;\n        }\n\n        let mastraArgs = t.objectExpression([]);\n        if (t.isObjectExpression(path.node.arguments[0])) {\n          mastraArgs = path.node.arguments[0];\n        }\n\n        let telemetry = mastraArgs.properties.find(\n          // @ts-ignore\n          prop => prop.key.name === option,\n        );\n        let telemetryValue: types.Expression = t.objectExpression([]);\n\n        const programPath = path.scope.getProgramParent().path as NodePath<types.Program> | undefined;\n        if (!programPath) {\n          return;\n        }\n\n        if (telemetry && t.isObjectProperty(telemetry) && t.isExpression(telemetry.value)) {\n          result.hasCustomConfig = true;\n          telemetryValue = telemetry.value;\n\n          if (t.isIdentifier(telemetry.value) && telemetry.value.name === option) {\n            const telemetryBinding = state.file.scope.getBinding(option)!;\n\n            if (telemetryBinding && t.isVariableDeclarator(telemetryBinding.path.node)) {\n              const id = path.scope.generateUidIdentifier(option);\n\n              telemetryBinding.path.replaceWith(t.variableDeclarator(id, telemetryBinding.path.node.init!));\n              telemetryValue = id;\n            }\n          }\n        }\n\n        // add the deployer export\n        const exportDeclaration = t.exportNamedDeclaration(\n          t.variableDeclaration('const', [t.variableDeclarator(t.identifier(option), telemetryValue)]),\n          [],\n        );\n\n        programPath.node.body.push(exportDeclaration);\n      },\n\n      Program: {\n        exit(path) {\n          // Add a fallback export if no mastra configuration was found\n          const hasExport = path.node.body.some(\n            node => node.type === 'ExportNamedDeclaration' || node.type === 'ExportDefaultDeclaration',\n          );\n\n          if (!hasExport) {\n            if (logger) {\n              logger.warn(`Mastra ${option} config could not be extracted. Please make sure your entry file looks like this:\nexport const mastra = new Mastra({\n  ${option}: <value>\n})\n\n`);\n            }\n\n            const fallbackExportDeclaration = t.exportNamedDeclaration(\n              t.variableDeclaration('const', [t.variableDeclarator(t.identifier(option), t.objectExpression([]))]),\n              [],\n            );\n            path.node.body.push(fallbackExportDeclaration);\n          }\n        },\n      },\n    },\n  } as babel.PluginObj;\n}\n","import type { IMastraLogger } from '@mastra/core/logger';\nimport { removeAllOptionsFromMastraExcept } from './remove-all-options-except';\n\nexport function removeAllOptionsExceptBundler(result: { hasCustomConfig: boolean }, logger?: IMastraLogger) {\n  return removeAllOptionsFromMastraExcept(result, 'bundler', logger);\n}\n","import babel from '@babel/core';\n\nexport function removeNonReferencedNodes() {\n  const t = babel.types;\n\n  return {\n    name: 'remove-non-referenced-nodes',\n    visitor: {\n      Program(path) {\n        // Get the scope information\n        const scope = path.scope;\n\n        // Filter body to keep only referenced nodes\n        const currentBody = path.get('body');\n        const filteredBody = currentBody.filter(childPath => {\n          if (childPath.isExportDeclaration()) {\n            return true;\n          }\n\n          // For variable declarations, check if any declared variables are referenced\n          if (childPath.isVariableDeclaration()) {\n            return childPath.node.declarations.some(decl => {\n              if (!t.isIdentifier(decl.id)) {\n                return false;\n              }\n\n              const name = decl.id.name;\n              const binding = scope.getBinding(name);\n              // Keep if it has references or is exported\n              return binding && (binding.referenced || binding.referencePaths.length > 0);\n            });\n          }\n\n          // For function/class declarations, check if they're referenced\n          if (childPath.isFunctionDeclaration() || childPath.isClassDeclaration()) {\n            if (!t.isIdentifier(childPath.node.id)) {\n              return false;\n            }\n\n            const name = childPath.node.id.name;\n            const binding = scope.getBinding(name);\n            return binding && (binding.referenced || binding.referencePaths.length > 0);\n          }\n\n          // For imports, check if any imported items are referenced\n          if (childPath.isImportDeclaration()) {\n            return childPath.node.specifiers.some(specifier => {\n              const importedName = specifier.local.name;\n              const binding = scope.getBinding(importedName);\n              return binding && (binding.referenced || binding.referencePaths.length > 0);\n            });\n          }\n\n          // Default to keeping other node types\n          return false;\n        });\n\n        // Replace the program body with filtered nodes\n        path.set(\n          'body',\n          filteredBody.map(p => p.node),\n        );\n      },\n    },\n  } as babel.PluginObj;\n}\n","import * as babel from '@babel/core';\nimport { removeNonReferencedNodes } from '../babel/remove-non-referenced-nodes';\n\nexport function recursiveRemoveNonReferencedNodes(code: string) {\n  return new Promise<{ code: string; map: any }>(async (resolve, reject) => {\n    babel.transform(\n      code,\n      {\n        babelrc: false,\n        configFile: false,\n        plugins: [removeNonReferencedNodes()],\n      },\n      (err, result) => {\n        if (err) {\n          return reject(err);\n        }\n\n        // keep looping until the code is not changed\n        if (result && result.code! !== code) {\n          return recursiveRemoveNonReferencedNodes(result!.code!).then(resolve, reject);\n        }\n\n        resolve({\n          code: result!.code!,\n          map: result!.map!,\n        });\n      },\n    );\n  });\n}\n","import * as babel from '@babel/core';\nimport { rollup, type RollupOutput } from 'rollup';\nimport { esbuild } from '../plugins/esbuild';\nimport commonjs from '@rollup/plugin-commonjs';\nimport { tsConfigPaths } from '../plugins/tsconfig-paths';\nimport { recursiveRemoveNonReferencedNodes } from '../plugins/remove-unused-references';\nimport { optimizeLodashImports } from '@optimize-lodash/rollup-plugin';\nimport { removeAllOptionsFromMastraExcept } from '../babel/remove-all-options-except';\nimport json from '@rollup/plugin-json';\nimport type { IMastraLogger } from '@mastra/core/logger';\n\ntype Transformer = (\n  result: { hasCustomConfig: boolean },\n  logger?: IMastraLogger,\n) => ReturnType<typeof removeAllOptionsFromMastraExcept>;\n\nexport function extractMastraOptionBundler(\n  name: string,\n  entryFile: string,\n  transformer: Transformer,\n  result: {\n    hasCustomConfig: false;\n  },\n  logger?: IMastraLogger,\n) {\n  return rollup({\n    logLevel: 'silent',\n    input: {\n      [`${name}-config`]: entryFile,\n    },\n    treeshake: 'smallest',\n    plugins: [\n      tsConfigPaths(),\n      // transpile typescript to something we understand\n      esbuild(),\n      optimizeLodashImports(),\n      commonjs({\n        extensions: ['.js', '.ts'],\n        strictRequires: 'strict',\n        transformMixedEsModules: true,\n        ignoreTryCatch: false,\n      }),\n      json(),\n      {\n        name: `extract-${name}-config`,\n        transform(code, id) {\n          if (id !== entryFile) {\n            return;\n          }\n\n          return new Promise((resolve, reject) => {\n            babel.transform(\n              code,\n              {\n                babelrc: false,\n                configFile: false,\n                filename: id,\n                plugins: [transformer(result, logger)],\n              },\n              (err, result) => {\n                if (err) {\n                  return reject(err);\n                }\n\n                resolve({\n                  code: result!.code!,\n                  map: result!.map!,\n                });\n              },\n            );\n          });\n        },\n      },\n      // let esbuild remove all unused imports\n      esbuild(),\n      {\n        name: 'cleanup',\n        transform(code, id) {\n          if (id !== entryFile) {\n            return;\n          }\n\n          return recursiveRemoveNonReferencedNodes(code);\n        },\n      },\n      // let esbuild remove it once more\n      esbuild(),\n    ],\n  });\n}\n\nexport async function extractMastraOption<T>(\n  name: string,\n  entryFile: string,\n  transformer: Transformer,\n  outputDir: string,\n  logger?: IMastraLogger,\n): Promise<{\n  bundleOutput: RollupOutput;\n  getConfig: () => Promise<T>;\n} | null> {\n  const result = {\n    hasCustomConfig: false,\n  } as const;\n  const bundler = await extractMastraOptionBundler(name, entryFile, transformer, result, logger);\n\n  const output = await bundler.write({\n    dir: outputDir,\n    format: 'es',\n    entryFileNames: '[name].mjs',\n  });\n\n  if (result.hasCustomConfig) {\n    const configPath = `${outputDir}/${name}-config.mjs`;\n\n    return {\n      bundleOutput: output,\n      getConfig: () => import(`file:${configPath}`).then(m => m[name] as T),\n    };\n  }\n\n  return null;\n}\n","import { removeAllOptionsExceptBundler } from './babel/remove-all-options-bundler';\nimport type { Config } from '@mastra/core/mastra';\nimport { extractMastraOption, extractMastraOptionBundler } from './shared/extract-mastra-option';\nimport type { IMastraLogger } from '@mastra/core/logger';\n\nexport function getBundlerOptionsBundler(\n  entryFile: string,\n  result: {\n    hasCustomConfig: false;\n  },\n) {\n  return extractMastraOptionBundler('bundler', entryFile, removeAllOptionsExceptBundler, result);\n}\n\nexport async function getBundlerOptions(\n  entryFile: string,\n  outputDir: string,\n  logger?: IMastraLogger,\n): Promise<Config['bundler'] | null> {\n  const result = await extractMastraOption<Config['bundler']>(\n    'bundler',\n    entryFile,\n    removeAllOptionsExceptBundler,\n    outputDir,\n    logger,\n  );\n\n  if (!result) {\n    return null;\n  }\n\n  return result.getConfig();\n}\n","import type { PluginObj } from '@babel/core';\nimport babel from '@babel/core';\n\nexport function checkConfigExport(result: { hasValidConfig: boolean }): PluginObj {\n  const t = babel.types;\n  // Track which local variable names are assigned to `new Mastra()`\n  const mastraVars = new Set<string>();\n\n  return {\n    visitor: {\n      ExportNamedDeclaration(path) {\n        const decl = path.node.declaration;\n        // 1) export const mastra = new Mastra(...)\n        if (t.isVariableDeclaration(decl)) {\n          const varDecl = decl.declarations[0];\n          if (\n            t.isIdentifier(varDecl?.id, { name: 'mastra' }) &&\n            t.isNewExpression(varDecl.init) &&\n            t.isIdentifier(varDecl.init.callee, { name: 'Mastra' })\n          ) {\n            result.hasValidConfig = true;\n          }\n        }\n        /**\n         * 2) export { foo as mastra }\n         * 3) export { mastra }\n         * 4) export { mastra, foo }\n         */\n        if (Array.isArray(path.node.specifiers)) {\n          for (const spec of path.node.specifiers) {\n            if (\n              t.isExportSpecifier(spec) &&\n              t.isIdentifier(spec.exported, { name: 'mastra' }) &&\n              t.isIdentifier(spec.local) &&\n              mastraVars.has(spec.local.name)\n            ) {\n              result.hasValidConfig = true;\n            }\n          }\n        }\n      },\n      // For cases 2-4 we need to track whether those variables are assigned to `new Mastra()`\n      VariableDeclaration(path) {\n        for (const decl of path.node.declarations) {\n          if (\n            t.isIdentifier(decl.id) &&\n            t.isNewExpression(decl.init) &&\n            t.isIdentifier(decl.init.callee, { name: 'Mastra' })\n          ) {\n            mastraVars.add(decl.id.name);\n          }\n        }\n      },\n    },\n  };\n}\n","import { execSync } from 'child_process';\nimport { existsSync, mkdirSync } from 'fs';\nimport { join } from 'path';\nimport { getPackageInfo } from 'local-pkg';\n\nexport function upsertMastraDir({ dir = process.cwd() }: { dir?: string }) {\n  const dirPath = join(dir, '.mastra');\n\n  if (!existsSync(dirPath)) {\n    mkdirSync(dirPath, { recursive: true });\n    execSync(`echo \".mastra\" >> .gitignore`);\n  }\n}\n\n/**\n * Get the package name from a module ID\n */\nexport function getPackageName(id: string) {\n  const parts = id.split('/');\n\n  if (id.startsWith('@')) {\n    return parts.slice(0, 2).join('/');\n  }\n\n  return parts[0];\n}\n\n/**\n * Get package root path\n */\nexport async function getPackageRootPath(packageName: string): Promise<string | null> {\n  let rootPath: string | null;\n\n  try {\n    const pkg = await getPackageInfo(packageName);\n    rootPath = pkg?.rootPath ?? null;\n  } catch (e) {\n    rootPath = null;\n  }\n\n  return rootPath;\n}\n\n/**\n * During `mastra dev` we are compiling TS files to JS (inside workspaces) so that users can just their workspace packages.\n * We store these compiled files inside `node_modules/.cache` for each workspace package.\n */\nexport function getCompiledDepCachePath(rootPath: string, packageName: string) {\n  return join(rootPath, 'node_modules', '.cache', packageName);\n}\n","import { join } from 'node:path';\nimport type { IMastraLogger } from '@mastra/core/logger';\nimport slugify from '@sindresorhus/slugify';\nimport { findWorkspaces, findWorkspacesRoot } from 'find-workspaces';\nimport { ensureDir } from 'fs-extra';\nimport { DepsService } from '../services';\n\nexport type WorkspacePackageInfo = {\n  location: string;\n  dependencies: Record<string, string> | undefined;\n  version: string | undefined;\n};\n\ntype TransitiveDependencyResult = {\n  resolutions: Record<string, string>;\n  usedWorkspacePackages: Set<string>;\n};\n\n/**\n * Creates a map of workspace packages with their metadata for dependency resolution\n * @returns Map of package names to their location, dependencies and version\n */\nexport const createWorkspacePackageMap = async () => {\n  // TODO move to our own implementation - pkg is 4 years old\n  const workspaces = await findWorkspaces();\n  const workspaceMap = new Map(\n    workspaces?.map(workspace => [\n      workspace.package.name,\n      {\n        location: workspace.location,\n        dependencies: workspace.package.dependencies,\n        version: workspace.package.version,\n      },\n    ]) ?? [],\n  );\n\n  return workspaceMap;\n};\n\n/**\n * Collects all transitive workspace dependencies and their TGZ paths\n */\nexport const collectTransitiveWorkspaceDependencies = ({\n  workspaceMap,\n  initialDependencies,\n  logger,\n}: {\n  workspaceMap: Map<string, WorkspacePackageInfo>;\n  initialDependencies: Set<string>;\n  logger: IMastraLogger;\n}): TransitiveDependencyResult => {\n  const usedWorkspacePackages = new Set<string>();\n  const queue: string[] = Array.from(initialDependencies);\n  const resolutions: Record<string, string> = {};\n\n  while (queue.length > 0) {\n    const len = queue.length;\n    for (let i = 0; i < len; i += 1) {\n      const pkgName = queue.shift();\n      if (!pkgName || usedWorkspacePackages.has(pkgName)) {\n        continue;\n      }\n\n      const dep = workspaceMap.get(pkgName);\n      if (!dep) continue;\n\n      const root = findWorkspacesRoot();\n      if (!root) {\n        throw new Error('Could not find workspace root');\n      }\n\n      const depsService = new DepsService(root.location);\n      depsService.__setLogger(logger);\n      const sanitizedName = slugify(pkgName);\n\n      const tgzPath = depsService.getWorkspaceDependencyPath({\n        pkgName: sanitizedName,\n        version: dep.version!,\n      });\n      resolutions[pkgName] = tgzPath;\n      usedWorkspacePackages.add(pkgName);\n\n      for (const [depName, _depVersion] of Object.entries(dep?.dependencies ?? {})) {\n        if (!usedWorkspacePackages.has(depName) && workspaceMap.has(depName)) {\n          queue.push(depName);\n        }\n      }\n    }\n  }\n\n  return { resolutions, usedWorkspacePackages };\n};\n\n/**\n * Creates TGZ packages for workspace dependencies in the workspace-module directory\n */\nexport const packWorkspaceDependencies = async ({\n  workspaceMap,\n  usedWorkspacePackages,\n  bundleOutputDir,\n  logger,\n}: {\n  workspaceMap: Map<string, WorkspacePackageInfo>;\n  bundleOutputDir: string;\n  logger: IMastraLogger;\n  usedWorkspacePackages: Set<string>;\n}): Promise<void> => {\n  const root = findWorkspacesRoot();\n  if (!root) {\n    throw new Error('Could not find workspace root');\n  }\n\n  const depsService = new DepsService(root.location);\n  depsService.__setLogger(logger);\n\n  // package all workspace dependencies\n  if (usedWorkspacePackages.size > 0) {\n    const workspaceDirPath = join(bundleOutputDir, 'workspace-module');\n    await ensureDir(workspaceDirPath);\n\n    logger.info(`Packaging ${usedWorkspacePackages.size} workspace dependencies...`);\n\n    const batchSize = 5;\n    const packages = Array.from(usedWorkspacePackages.values());\n\n    for (let i = 0; i < packages.length; i += batchSize) {\n      const batch = packages.slice(i, i + batchSize);\n      logger.info(\n        `Packaging batch ${Math.floor(i / batchSize) + 1}/${Math.ceil(packages.length / batchSize)}: ${batch.join(', ')}`,\n      );\n      await Promise.all(\n        batch.map(async pkgName => {\n          const dep = workspaceMap.get(pkgName);\n          const sanitizedName = slugify(pkgName);\n          if (!dep) return;\n\n          await depsService.pack({ dir: dep.location, destination: workspaceDirPath, sanitizedName: sanitizedName });\n        }),\n      );\n    }\n\n    logger.info(`Successfully packaged ${usedWorkspacePackages.size} workspace dependencies`);\n  }\n};\n","import type { IMastraLogger } from '@mastra/core/logger';\nimport * as babel from '@babel/core';\nimport commonjs from '@rollup/plugin-commonjs';\nimport json from '@rollup/plugin-json';\nimport nodeResolve from '@rollup/plugin-node-resolve';\nimport virtual from '@rollup/plugin-virtual';\nimport esmShim from '@rollup/plugin-esm-shim';\nimport { existsSync } from 'node:fs';\nimport { readFile } from 'node:fs/promises';\nimport { fileURLToPath } from 'node:url';\nimport { rollup, type OutputAsset, type OutputChunk, type Plugin } from 'rollup';\nimport { esbuild } from './plugins/esbuild';\nimport { isNodeBuiltin } from './isNodeBuiltin';\nimport { aliasHono } from './plugins/hono-alias';\nimport { removeDeployer } from './plugins/remove-deployer';\nimport { join } from 'node:path';\nimport { validate } from '../validator/validate';\nimport { tsConfigPaths } from './plugins/tsconfig-paths';\nimport { writeFile } from 'node:fs/promises';\nimport { getBundlerOptions } from './bundlerOptions';\nimport { checkConfigExport } from './babel/check-config-export';\nimport { getCompiledDepCachePath, getPackageName, getPackageRootPath } from './utils';\nimport { createWorkspacePackageMap, type WorkspacePackageInfo } from '../bundler/workspaceDependencies';\nimport type { DependencyMetadata } from './types';\n\n// TODO: Make this extendable or find a rollup plugin that can do this\nconst globalExternals = [\n  'pino',\n  'pino-pretty',\n  '@libsql/client',\n  'pg',\n  'libsql',\n  'jsdom',\n  'sqlite3',\n  'fastembed',\n  'nodemailer',\n  '#tools',\n];\n\nfunction findExternalImporter(module: OutputChunk, external: string, allOutputs: OutputChunk[]): OutputChunk | null {\n  const capturedFiles = new Set();\n\n  for (const id of module.imports) {\n    if (id === external) {\n      return module;\n    } else {\n      if (id.endsWith('.mjs')) {\n        capturedFiles.add(id);\n      }\n    }\n  }\n\n  for (const file of capturedFiles) {\n    const nextModule = allOutputs.find(o => o.fileName === file);\n    if (nextModule) {\n      const importer = findExternalImporter(nextModule, external, allOutputs);\n\n      if (importer) {\n        return importer;\n      }\n    }\n  }\n\n  return null;\n}\n\n/**\n * Analyzes the entry file to identify dependencies that need optimization.\n * This is the first step of the bundle analysis process.\n *\n * @param entry - The entry file path or content\n * @param mastraEntry - The mastra entry point\n * @param isVirtualFile - Whether the entry is a virtual file (content string) or a file path\n * @param platform - Target platform (node or browser)\n * @param logger - Logger instance for debugging\n * @returns Map of dependencies to optimize with their metadata (exported bindings, rootPath, isWorkspace)\n */\nasync function analyze(\n  entry: string,\n  mastraEntry: string,\n  isVirtualFile: boolean,\n  platform: 'node' | 'browser',\n  logger: IMastraLogger,\n  sourcemapEnabled: boolean = false,\n  workspaceMap: Map<string, WorkspacePackageInfo>,\n) {\n  logger.info('Analyzing dependencies...');\n  let virtualPlugin = null;\n  if (isVirtualFile) {\n    virtualPlugin = virtual({\n      '#entry': entry,\n    });\n    entry = '#entry';\n  }\n\n  const normalizedMastraEntry = mastraEntry.replaceAll('\\\\', '/');\n  const optimizerBundler = await rollup({\n    logLevel: process.env.MASTRA_BUNDLER_DEBUG === 'true' ? 'debug' : 'silent',\n    input: isVirtualFile ? '#entry' : entry,\n    treeshake: 'smallest',\n    preserveSymlinks: true,\n    plugins: [\n      virtualPlugin,\n      tsConfigPaths(),\n      {\n        name: 'custom-alias-resolver',\n        resolveId(id: string) {\n          if (id === '#server') {\n            return fileURLToPath(import.meta.resolve('@mastra/deployer/server')).replaceAll('\\\\', '/');\n          }\n          if (id === '#mastra') {\n            return normalizedMastraEntry;\n          }\n          if (id.startsWith('@mastra/server')) {\n            return fileURLToPath(import.meta.resolve(id));\n          }\n\n          // Tools is generated dependency, we don't want it to be handled by the bundler but instead read from disk at runtime\n          if (id === '#tools') {\n            return {\n              id: '#tools',\n              external: true,\n            };\n          }\n        },\n      } satisfies Plugin,\n      json(),\n      esbuild(),\n      commonjs({\n        strictRequires: 'debug',\n        ignoreTryCatch: false,\n        transformMixedEsModules: true,\n        extensions: ['.js', '.ts'],\n      }),\n      removeDeployer(normalizedMastraEntry, { sourcemap: sourcemapEnabled }),\n      esbuild(),\n    ].filter(Boolean),\n  });\n\n  const { output } = await optimizerBundler.generate({\n    format: 'esm',\n    inlineDynamicImports: true,\n  });\n\n  await optimizerBundler.close();\n\n  const depsToOptimize = new Map<string, DependencyMetadata>();\n\n  for (const [dep, bindings] of Object.entries(output[0].importedBindings)) {\n    // Skip node built-in\n    if (isNodeBuiltin(dep)) {\n      continue;\n    }\n\n    const isWorkspace = workspaceMap.has(dep);\n\n    const pkgName = getPackageName(dep);\n    let rootPath: string | null = null;\n\n    if (pkgName && pkgName !== '#tools') {\n      rootPath = await getPackageRootPath(pkgName);\n    }\n\n    depsToOptimize.set(dep, { exports: bindings, rootPath, isWorkspace });\n  }\n\n  for (const o of output) {\n    if (o.type !== 'chunk') {\n      continue;\n    }\n\n    // Tools is generated dependency, we don't want our analyzer to handle it\n    const dynamicImports = o.dynamicImports.filter(d => d !== '#tools');\n    if (!dynamicImports.length) {\n      continue;\n    }\n\n    for (const dynamicImport of dynamicImports) {\n      if (!depsToOptimize.has(dynamicImport) && !isNodeBuiltin(dynamicImport)) {\n        depsToOptimize.set(dynamicImport, { exports: ['*'], rootPath: null, isWorkspace: false });\n      }\n    }\n  }\n\n  return depsToOptimize;\n}\n\n/**\n * Bundles vendor dependencies identified in the analysis step.\n * Creates virtual modules for each dependency and bundles them using rollup.\n *\n * @param depsToOptimize - Map of dependencies to optimize with their metadata (exported bindings, rootPath, isWorkspace)\n * @param outputDir - Directory where bundled files will be written\n * @param logger - Logger instance for debugging\n * @returns Object containing bundle output and reference map for validation\n */\nexport async function bundleExternals(\n  depsToOptimize: Map<string, DependencyMetadata>,\n  outputDir: string,\n  logger: IMastraLogger,\n  bundlerOptions?: {\n    externals?: string[];\n    transpilePackages?: string[];\n    isDev?: boolean;\n  },\n  meta?: {\n    workspaceRoot?: string;\n    workspaceMap?: Map<string, WorkspacePackageInfo>;\n  },\n) {\n  logger.info('Optimizing dependencies...');\n  logger.debug(\n    `${Array.from(depsToOptimize.keys())\n      .map(key => `- ${key}`)\n      .join('\\n')}`,\n  );\n\n  const { externals: customExternals = [], transpilePackages = [], isDev = false } = bundlerOptions || {};\n  const { workspaceRoot = null, workspaceMap = new Map() } = meta || {};\n  const allExternals = [...globalExternals, ...customExternals];\n  const reverseVirtualReferenceMap = new Map<string, string>();\n  const virtualDependencies = new Map();\n\n  for (const [dep, { exports, isWorkspace, rootPath }] of depsToOptimize.entries()) {\n    let name = dep.replaceAll('/', '-');\n\n    if (isWorkspace && rootPath && isDev && workspaceRoot) {\n      const absolutePath = getCompiledDepCachePath(rootPath, name);\n\n      /**\n       * Further below `[name].mjs` is used. By making the name something like `packages/bar/node_modules/.cache/@monorepo-bar` Rollup writes the file to that path. For this also the `dir` needs adjusting.\n       */\n      name = absolutePath\n        /**\n         * The Rollup output.entryFileNames option doesn't allow relative or absolute paths, so the cacheDirAbsolutePath needs to be converted to a name relative to the workspace root.\n         */\n        .replace(workspaceRoot, '')\n        /**\n         * Remove leading slashes/backslashes\n         */\n        .replace(/^[/\\\\]+/, '');\n    }\n\n    reverseVirtualReferenceMap.set(name, dep);\n\n    const virtualFile: string[] = [];\n    let exportStringBuilder = [];\n    for (const local of exports) {\n      if (local === '*') {\n        virtualFile.push(`export * from '${dep}';`);\n      } else if (local === 'default') {\n        virtualFile.push(`export { default } from '${dep}';`);\n      } else {\n        exportStringBuilder.push(local);\n      }\n    }\n\n    if (exportStringBuilder.length > 0) {\n      virtualFile.push(`export { ${exportStringBuilder.join(', ')} } from '${dep}';`);\n    }\n\n    virtualDependencies.set(dep, {\n      name,\n      virtual: virtualFile.join('\\n'),\n    });\n  }\n\n  const transpilePackagesMap = new Map<string, string>();\n  for (const pkg of transpilePackages) {\n    const dir = await getPackageRootPath(pkg);\n\n    if (dir) {\n      transpilePackagesMap.set(pkg, dir);\n    }\n  }\n\n  const bundler = await rollup({\n    logLevel: process.env.MASTRA_BUNDLER_DEBUG === 'true' ? 'debug' : 'silent',\n    input: Array.from(virtualDependencies.entries()).reduce(\n      (acc, [dep, virtualDep]) => {\n        acc[virtualDep.name] = `#virtual-${dep}`;\n        return acc;\n      },\n      {} as Record<string, string>,\n    ),\n    external: allExternals,\n    treeshake: 'smallest',\n    plugins: [\n      virtual(\n        Array.from(virtualDependencies.entries()).reduce(\n          (acc, [dep, virtualDep]) => {\n            acc[`#virtual-${dep}`] = virtualDep.virtual;\n            return acc;\n          },\n          {} as Record<string, string>,\n        ),\n      ),\n      transpilePackagesMap.size\n        ? esbuild({\n            format: 'esm',\n            include: [...transpilePackagesMap.values()].map(p => {\n              // Match files from transpilePackages but exclude any nested node_modules\n              // Escapes regex special characters in the path and uses negative lookahead to avoid node_modules\n              // generated by cursor\n              return new RegExp(`^${p.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')}/(?!.*node_modules).*$`);\n            }),\n          })\n        : null,\n      commonjs({\n        strictRequires: 'strict',\n        transformMixedEsModules: true,\n        ignoreTryCatch: false,\n      }),\n      isDev ? esmShim() : undefined,\n      nodeResolve({\n        preferBuiltins: true,\n        exportConditions: ['node'],\n        // Do not embed external dependencies into files that we write to `node_modules/.cache` (for the mastra dev + workspace use case)\n        ...(workspaceMap.size > 0 && isDev ? { resolveOnly: Array.from(workspaceMap.keys()) } : {}),\n      }),\n      // hono is imported from deployer, so we need to resolve from here instead of the project root\n      aliasHono(),\n      json(),\n    ].filter(Boolean),\n  });\n\n  const { output } = await bundler.write({\n    format: 'esm',\n    /**\n     * If Mastra is used inside a monorepo, we need to find the workspace root so that Rollup can use it as base for the output dir. This should only happen during `mastra dev`.\n     *\n     * Otherwise, use outputDir as normal.\n     */\n    dir: isDev ? (workspaceRoot ? workspaceRoot : outputDir) : outputDir,\n    entryFileNames: '[name].mjs',\n    chunkFileNames: '[name].mjs',\n    hoistTransitiveImports: false,\n  });\n  const moduleResolveMap = {} as Record<string, Record<string, string>>;\n  const filteredChunks = output.filter(o => o.type === 'chunk');\n\n  for (const o of filteredChunks.filter(o => o.isEntry || o.isDynamicEntry)) {\n    for (const external of allExternals) {\n      if (external === '#tools') {\n        continue;\n      }\n\n      const importer = findExternalImporter(o, external, filteredChunks);\n\n      if (importer) {\n        const fullPath = join(outputDir, importer.fileName);\n        moduleResolveMap[fullPath] = moduleResolveMap[fullPath] || {};\n        if (importer.moduleIds.length) {\n          moduleResolveMap[fullPath][external] = importer.moduleIds[importer.moduleIds.length - 1]?.startsWith(\n            '\\x00virtual:#virtual',\n          )\n            ? importer.moduleIds[importer.moduleIds.length - 2]!\n            : importer.moduleIds[importer.moduleIds.length - 1]!;\n        }\n      }\n    }\n  }\n\n  await writeFile(join(outputDir, 'module-resolve-map.json'), JSON.stringify(moduleResolveMap, null, 2));\n\n  await bundler.close();\n\n  return { output, reverseVirtualReferenceMap, usedExternals: moduleResolveMap };\n}\n\n/**\n * Validates the bundled output by attempting to import each generated module.\n * Tracks invalid chunks and external dependencies that couldn't be bundled.\n *\n * @param output - Bundle output from rollup\n * @param reverseVirtualReferenceMap - Map to resolve virtual module names back to original deps\n * @param outputDir - Directory containing the bundled files\n * @param logger - Logger instance for debugging\n * @param workspaceMap - Map of workspace packages that gets directly passed through for later consumption\n * @returns Analysis result containing invalid chunks and dependency mappings\n */\nasync function validateOutput(\n  {\n    output,\n    reverseVirtualReferenceMap,\n    usedExternals,\n    outputDir,\n    workspaceMap,\n  }: {\n    output: (OutputChunk | OutputAsset)[];\n    reverseVirtualReferenceMap: Map<string, string>;\n    usedExternals: Record<string, Record<string, string>>;\n    outputDir: string;\n    workspaceMap: Map<string, WorkspacePackageInfo>;\n  },\n  logger: IMastraLogger,\n) {\n  const result = {\n    invalidChunks: new Set<string>(),\n    dependencies: new Map<string, string>(),\n    externalDependencies: new Set<string>(),\n    workspaceMap,\n  };\n\n  // we should resolve the version of the deps\n  for (const deps of Object.values(usedExternals)) {\n    for (const dep of Object.keys(deps)) {\n      result.externalDependencies.add(dep);\n    }\n  }\n\n  for (const file of output) {\n    if (file.type === 'asset') {\n      continue;\n    }\n\n    try {\n      logger.debug(`Validating if ${file.fileName} is a valid module.`);\n      if (file.isEntry && reverseVirtualReferenceMap.has(file.name)) {\n        result.dependencies.set(reverseVirtualReferenceMap.get(file.name)!, file.fileName);\n      }\n\n      if (!file.isDynamicEntry && file.isEntry) {\n        // validate if the chunk is actually valid, a failsafe to make sure bundling didn't make any mistakes\n        await validate(join(outputDir, file.fileName));\n      }\n    } catch (err) {\n      result.invalidChunks.add(file.fileName);\n      if (file.isEntry && reverseVirtualReferenceMap.has(file.name)) {\n        const reference = reverseVirtualReferenceMap.get(file.name)!;\n        const dep = reference.startsWith('@') ? reference.split('/').slice(0, 2).join('/') : reference.split('/')[0];\n\n        result.externalDependencies.add(dep!);\n      }\n\n      // we might need this on other projects but not sure so let's keep it commented out for now\n      // console.log(file.fileName, file.isEntry, file.isDynamicEntry, err);\n      // result.invalidChunks.add(file.fileName);\n      // const externalImports = excludeInternalDeps(file.imports.filter(file => !internalFiles.has(file)));\n      // externalImports.push(...excludeInternalDeps(file.dynamicImports.filter(file => !internalFiles.has(file))));\n      // for (const externalImport of externalImports) {\n      //   result.externalDependencies.add(externalImport);\n      // }\n\n      // if (reverseVirtualReferenceMap.has(file.name)) {\n      //   result.externalDependencies.add(reverseVirtualReferenceMap.get(file.name)!);\n      // }\n    }\n  }\n\n  return result;\n}\n\n/**\n * Main bundle analysis function that orchestrates the three-step process:\n * 1. Analyze dependencies\n * 2. Bundle dependencies modules\n * 3. Validate generated bundles\n *\n * This helps identify which dependencies need to be externalized vs bundled.\n */\nexport async function analyzeBundle(\n  entries: string[],\n  mastraEntry: string,\n  outputDir: string,\n  platform: 'node' | 'browser',\n  logger: IMastraLogger,\n  sourcemapEnabled: boolean = false,\n) {\n  const mastraConfig = await readFile(mastraEntry, 'utf-8');\n  const mastraConfigResult = {\n    hasValidConfig: false,\n  } as const;\n\n  await babel.transformAsync(mastraConfig, {\n    filename: mastraEntry,\n    presets: [import.meta.resolve('@babel/preset-typescript')],\n    plugins: [checkConfigExport(mastraConfigResult)],\n  });\n\n  if (!mastraConfigResult.hasValidConfig) {\n    logger.warn(`Invalid Mastra config. Please make sure that your entry file looks like this:\nexport const mastra = new Mastra({\n  // your options\n})\n  \nIf you think your configuration is valid, please open an issue.`);\n  }\n\n  const workspaceMap = await createWorkspacePackageMap();\n\n  const depsToOptimize = new Map<string, DependencyMetadata>();\n  for (const entry of entries) {\n    const isVirtualFile = entry.includes('\\n') || !existsSync(entry);\n    const analyzeResult = await analyze(\n      entry,\n      mastraEntry,\n      isVirtualFile,\n      platform,\n      logger,\n      sourcemapEnabled,\n      workspaceMap,\n    );\n\n    for (const [dep, { exports }] of analyzeResult.entries()) {\n      if (depsToOptimize.has(dep)) {\n        // Merge with existing exports if dependency already exists\n        const existingEntry = depsToOptimize.get(dep)!;\n        depsToOptimize.set(dep, {\n          ...existingEntry,\n          exports: [...new Set([...existingEntry.exports, ...exports])],\n        });\n      } else {\n        const isWorkspace = workspaceMap.has(dep);\n\n        const pkgName = getPackageName(dep);\n        let rootPath: string | null = null;\n\n        if (pkgName && pkgName !== '#tools') {\n          rootPath = await getPackageRootPath(pkgName);\n        }\n\n        depsToOptimize.set(dep, { exports, rootPath, isWorkspace });\n      }\n    }\n  }\n  const bundlerOptions = await getBundlerOptions(mastraEntry, outputDir);\n\n  const { output, reverseVirtualReferenceMap, usedExternals } = await bundleExternals(\n    depsToOptimize,\n    outputDir,\n    logger,\n    bundlerOptions ?? undefined,\n  );\n  const result = await validateOutput(\n    { output, reverseVirtualReferenceMap, usedExternals, outputDir, workspaceMap },\n    logger,\n  );\n\n  return result;\n}\n"]}