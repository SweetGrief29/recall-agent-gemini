'use strict';

var chunkJOCAZKZ5_cjs = require('./chunk-JOCAZKZ5.cjs');
var chunkT4L3WY7M_cjs = require('./chunk-T4L3WY7M.cjs');
var rollup = require('rollup');
var findWorkspaces = require('find-workspaces');
var path = require('path');
var resolveFrom = require('resolve-from');
var module$1 = require('module');
var logger = require('@mastra/core/logger');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

var resolveFrom__default = /*#__PURE__*/_interopDefault(resolveFrom);

function isBuiltinModule(specifier) {
  return module$1.builtinModules.includes(specifier) || specifier.startsWith("node:") || module$1.builtinModules.includes(specifier.replace(/^node:/, ""));
}
function safeResolve(id, importer) {
  try {
    return resolveFrom__default.default(importer, id);
  } catch {
    return null;
  }
}
function nodeModulesExtensionResolver() {
  return {
    name: "node-modules-extension-resolver",
    resolveId(id, importer) {
      if (id.startsWith(".") || id.startsWith("/") || !importer) {
        return null;
      }
      if (isBuiltinModule(id)) {
        return null;
      }
      if (id.startsWith("@") && id.split("/").length === 2) {
        return null;
      }
      if (!id.startsWith("@") && id.split("/").length === 1) {
        return null;
      }
      const foundExt = path.extname(id);
      if (foundExt) {
        return null;
      }
      try {
        const resolved = undefined(id);
        if (!path.extname(resolved)) {
          throw new Error(`Cannot resolve ${id} from ${importer}`);
        }
        return null;
      } catch (e) {
        const resolved = safeResolve(id, importer);
        if (resolved) {
          return {
            id: resolved,
            external: true
          };
        }
        for (const ext of [".mjs", ".js", ".cjs"]) {
          const resolved2 = safeResolve(id + ext, importer);
          if (resolved2) {
            const pkgName = chunkT4L3WY7M_cjs.getPackageName(id);
            if (!pkgName) {
              return null;
            }
            const pkgJsonPath = safeResolve(`${pkgName}/package.json`, importer);
            if (!pkgJsonPath) {
              return null;
            }
            const newImportWithExtension = resolved2.replace(path.dirname(pkgJsonPath), pkgName);
            return {
              id: newImportWithExtension,
              external: true
            };
          }
        }
      }
      return null;
    }
  };
}
async function getInputOptions2(entryFile, platform, env, { sourcemap = false, transpilePackages = [] } = {}) {
  const dependencies = /* @__PURE__ */ new Map();
  const workspaceMap = await chunkT4L3WY7M_cjs.createWorkspacePackageMap();
  const workspaceRoot = findWorkspaces.findWorkspacesRoot()?.location;
  const depsToOptimize = /* @__PURE__ */ new Map();
  if (transpilePackages.length) {
    for (const pkg of transpilePackages) {
      const isWorkspace = workspaceMap.has(pkg);
      const exports = ["*"];
      const pkgName = chunkT4L3WY7M_cjs.getPackageName(pkg);
      let rootPath = null;
      if (pkgName && pkgName !== "#tools") {
        rootPath = await chunkT4L3WY7M_cjs.getPackageRootPath(pkgName);
      }
      depsToOptimize.set(pkg, { exports, isWorkspace, rootPath });
    }
    const { output, reverseVirtualReferenceMap } = await chunkT4L3WY7M_cjs.bundleExternals(
      depsToOptimize,
      ".mastra/.build",
      logger.noopLogger,
      {
        transpilePackages,
        isDev: true
      },
      { workspaceRoot, workspaceMap }
    );
    for (const file of output) {
      if (file.type === "asset") {
        continue;
      }
      if (file.isEntry && reverseVirtualReferenceMap.has(file.name)) {
        dependencies.set(reverseVirtualReferenceMap.get(file.name), file.fileName);
      }
    }
  }
  const inputOptions = await chunkJOCAZKZ5_cjs.getInputOptions(
    entryFile,
    {
      dependencies,
      externalDependencies: /* @__PURE__ */ new Set(),
      invalidChunks: /* @__PURE__ */ new Set(),
      workspaceMap
    },
    platform,
    env,
    { sourcemap, isDev: true, workspaceRoot }
  );
  if (Array.isArray(inputOptions.plugins)) {
    const plugins = [];
    inputOptions.plugins.forEach((plugin) => {
      if (plugin?.name === "node-resolve") {
        return;
      }
      if (plugin?.name === "tsconfig-paths") {
        plugins.push(
          chunkT4L3WY7M_cjs.tsConfigPaths({
            localResolve: true
          })
        );
        return;
      }
      plugins.push(plugin);
    });
    inputOptions.plugins = plugins;
    inputOptions.plugins.push(chunkT4L3WY7M_cjs.aliasHono());
    inputOptions.plugins.push(nodeModulesExtensionResolver());
  }
  return inputOptions;
}
async function createWatcher(inputOptions, outputOptions) {
  const watcher = await rollup.watch({
    ...inputOptions,
    output: {
      ...outputOptions,
      format: "esm",
      entryFileNames: "[name].mjs",
      chunkFileNames: "[name].mjs"
    }
  });
  return watcher;
}

// src/build/babel/remove-all-options-server.ts
function removeAllOptionsExceptServer(result, logger) {
  return chunkT4L3WY7M_cjs.removeAllOptionsFromMastraExcept(result, "server", logger);
}

// src/build/serverOptions.ts
async function getServerOptions(entryFile, outputDir, logger) {
  const result = await chunkT4L3WY7M_cjs.extractMastraOption(
    "server",
    entryFile,
    removeAllOptionsExceptServer,
    outputDir,
    logger
  );
  if (!result) {
    return null;
  }
  return result.getConfig();
}

exports.createWatcher = createWatcher;
exports.getInputOptions = getInputOptions2;
exports.getServerOptions = getServerOptions;
//# sourceMappingURL=chunk-ZQJDMTCN.cjs.map
//# sourceMappingURL=chunk-ZQJDMTCN.cjs.map